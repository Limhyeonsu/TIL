# 10. 대용량 처리를 위한 시스템 최적화
## 10.1 노드 실행환경과 JVM 옵션(487~498p)
* 엘라스틱서치 릴리스 노트
* 실행시 자바 8 이상을 사용해야 하는 이유
  * 큰 물리 메모리 사용
  * 다수의 CPU 사용
* 항상 최신 버전의 엘라스틱서치를 사용해야 하는 이유
* 자바 8에서 제공하는 JVM 옵선
* 엘라스틱서치에 적용된 JVM 옵션

## 10.2 힙 크기를 32GB 이하로 유지해야 하는 이유
너무 작은 힙 크기는 Out Of Memory Exception을 발생시킬 수 있으며, 반대로 너무 큰 힙 크기는 FullGC가 발생할 때 시스템 전체가 마비되는 STW(stop the world) 를 발생시킬 수 있다. 

### 엘라스틱서치와 힙 크기
기본대로 설정하면 힙 크기가 1GB로 설정돼 있다. (실제 운영환경에서는 반드시 1GB보다 큰 값으로 힙 크기를 변경해야 한다.)

config 파일에서 Xms(최소 힙 크기), Xmx(최대 힙 크기) 설정 값을 변경하면 된다. 여러가지 이유로 엘라스틱서치에서 할당할 힙 크기의 최댓값으로 32GB 이하를 설정하는 것을 권장한다.

* 운영체제에 50%의 메모리 공간을 보장하자 : 실시간 검색을 지원하기 위해 루씬이 최대한 많은 시스템 캐시를 확보하도록 지원해야 한다. 그러므로 물리적인 메모리 공간의 50% 정도는 운영체제가 자유롭게 사용하도록 할당하고 나머지는 엘라스틱서치 힙으로 할당하는 것이 적절하다.
* 자바8 기반에서는 힙 크기를 32GB 이상 사용하지 말자 : 자바 기반의 애플리케이션에는 Object Pointer 정책이 모두 동일하게 적용되기 때문에 모두 최대 힙 크기를 32GB로 제한한다.

### Ordinary Object Pointer 
자바에서는 모든 객체가 힙 영역에 생성되고, 생성된 객체는 모두 포인터를 가지고 있고 이 포인터를 이용해서 객체에 접근한다. JVM은 힙 영역에 생성된 객체에 접근하기 위해 포인터의 주소를 Ordinary Object Pointer 라고 하는 특수한 자료구조로 만들어서 관리하고 있다.

32비트에서 64비트로 JVM이 빠르게 전환되면서 OOP를 위해 낭비되는 메모리 문제가 크게 대두되었고 이런 문제를 해결하기 위해 기존의 OOP를 개선해서 Compressed OOP라는 새로운 개념의 포인터 관리 기법을 도입했다.

### Compressed Ordinary Object Pointer
자바의 경우 64비트 가상 머신의 성능 향상과 효율적인 메모리 사용을 위해 Compressed OOP라는 개념을 도입했다. 최신 JDK를 사용할 경우 Compressed OOP를 통해 64비트 시스템에서 힙 메모리를 좀 더 효율적으로 사용할 수 있다.

Compressed OOP는 포인터의 공간 낭비를 줄이고 좀 더 빠른 연산을 위해 포인터를 압축해서 표현하는 일종의 트릭이라고 할 수 있다. 

### 엘라스틱서치에서 힙 크기 설정하기
애플리케이션에서는 32GB 이하로 힙 크기를 설정할 경우 Compressed OOP를 기본적으로 사용하고, 만약 힙 크기가 32GB 이상을 넘어가면 내부적으로 포인터 구조가 Compressed OOP에서 일반 OOP방식으로 자동 전환된다. 

만약 수백 GC의 물리적인 메모리를 탑재한 서버가 있더라도 힙 크기를 32GB 이상으로 설정하지 말아야 한다. 이상으로 설정할 경우 메모리의 낭비도 심해지고 GC에도 많은 부담을 주게 되므로 차라리 하나의 물리적인 서버에서 다수의 엘라스틱서치 인스턴스를 생성하는 편이 훨씬 더 좋을 것이다.

* 적절한 성능의 서버를 가지고 있을 때 : 가급적 고성능 서버보단 63GB의 물리 메모리를 탑재한 다수의 서버를 운영하는 편이 유리하다
* 고성능 서버를 가지고 있을 때 : 서버에 탑재된 물리 메모리의 반을 32GB로 나눠서 그 수만큼의 엘라스틱서치 인스턴스를 생성한다. 
* 전문 검색을 주목적으로 엘라스틱서치를 사용하는 경우 : 힙에 32GB를 할당하고, 나머지를 운영체제에 남겨둬서 루씬이 시스템 캐시를 통해 메모리를 최대한으로 사용할 수 있게 한다.
* 일반적인 데이터 필드에서 정렬/집계 작업을 많이 수행하는 경우 : 숫자, 날짜, geo_point, keyword 같은 데이터 타입의 경우 필드가 별도의 분석 과정을 거치지 않는다. 이 경우 루씬의 DocValues를 사용하기 때문에 힙 공간은 거의 사용되지 않는다.
* 전문 필드에서 정렬/집계 작업을 많이 수행하는 경우 : 분석된 문자열 필드에서 정렬, 집계를 수행할 경우 루씬의 DocValues를 사용할 수 없기 때문에 fieldata라는 힙 기반의 캐시를 사용해야만 한다. 하지만 힙 크기가 너무 크면 메모리 낭비와 FullGC 문제가 발생하기 때문에 32GB의 힙 크기를 가진 엘라스틱서치 인스턴스를 여러 개 생성하는 방식으로 설정하는 것이 좋다.