# 9. 엘라스틱서치와 루씬 이야기
## 9.1 클러스터 관점에서 구성요소 살펴보기
엘라스틱서치는 기본적으로 클러스터라는 단위로 데이터를 제공한다. 클러스터는 하나 이상의 물리적인 노드로 이뤄져 있으며 각 노드는 모두 데이터 색인 및 검색 기능을 제공하는 일종의 물리적인 서버이기도 하다. 내부에는 루씬 라이브러리가 자리 잡고 있고, 이는 엘라스틱서치의 근간을 이루는 핵심 모듈이다.

1. 클러스터 : 데이터를 실제로 가지고 있는 __노드의 모음__ 이다. 엘라스틱서치에서는 관련된 모든 노드들을 논리적으로 확장해서 클러스터라고 부른다. 같은 클러스터 내에서만 데이터 공유가 가능하기 때문에 연관된 모든 노드는 하나의 클러스터에서 구성원으로 연결되는 것이 매우 중요하다.
2. 노드 : 물리적으로 실행된 런타임 상태의 엘라스틱서치를 노드라고 부른다. 노드는 논리적인 클러스터를 이루는 구성원의 일부이며 실제 데이터를 물리적으로 가지고 있는 단일 서버이기도 하다. 노드는 내부에 다수의 인덱스를 가지고 있고, 각 인덱스는 다수의 문서를 가지고 있다. 
   * 마스터 노드 - 클러스터의 제어 담당
   * 데이터 노드 - 데이터를 보유하고 CRUD, 검색, 집계 등 데이터 관련 작업 담당
   * 인제스트 노드 - 색인 전 전처리 작업 담당
   * 트라이브 노드 - 여러 클러스터를 제한적으로 연결해서 동시에 검색 수행 (특수한 목적의 노드)
   * 코디네이팅 노드 - 검색, 집계시 분산 처리만을 목적으로 설정된 노드
3. 인덱스 : 유사한 특성을 가지고 있는 문서를 모아둔 문서들의 컬렉션이다. 예) 고객정보, 상품정보, 주문정보 등 클러스터 내에서 `유일한 인덱스명`을 가져야 한다. 또한 인덱스명은 모두 `소문자`로 설정해야 한다.
4. 문서 : 검색 대상이 되는 실제 물리적인 데이터를 뜻한다. 엘라스틱서치에서는 JSON 형식으로 표현된다.
5. 샤드 : 인덱스에는 매우 __많은 양의 문서__ 가 저장될 수 있다. __물리적인 한계를 뛰어넘기 위해 나온 개념이 샤드이다.__ 이를 이용하면 데이터를 분산 저장하는 방식으로 손쉬운 수평 확장이 가능해진다. 인덱스 생성시 기본적으로 5개의 샤드로 데이터가 분산되도록 생성된다.
6. 레플리카 : 샤드의 복제본을 나타낸다. 인덱스 생성시 기본적으로 1개의 레플리카 세트를 생성한다. 검색시 레플리카가 적극적으로 활용되기 때문이 이를 이용하면 읽기 분산에 유리해진다. 인덱스 생성시 샤드수, 레플리카 개수를 자유롭게 설정할 수 있다. 단 인덱스 생성후 변경하는 것이 불가능하다. 
7. 세그먼트 : 샤드 내부에는 루씬 라이브러리를 포함하고 있는데, 이를 이용해 대부분의 검색 기능을 제공한다. 루씬에 데이터가 색인되면 데이터는 최소한의 단위인 토큰으로 분리되고 특수한 형태의 자료구조로 저장되는데 이런 자료구조를 세그먼트라고 한다. `세그먼트는 읽기에 최적화된 자료구조로서 역색인이라는 특수한 형태로 변환되어 물리적인 디스크에 저장된다.`

## 9.2 엘라스틱서치 샤드 VS 루씬 인덱스
457~459p

## 9.3 엘라스틱서치가 근실시간 검색을 제공하는 이유
엘라스틱서치는 처음부터 다양한 데이터의 색인이 가능하고 근실시간 검색을 제공하는 것을 목표로 개발됐다.

### 색인 작업시 세그먼트의 기본 동작 방식
하나의 루씬 인덱스는 내부적으로 다수의 세그먼트로 구성돼 있다. 

루씬은 검색 요청을 받으면 다수의 작은 세그먼트 조각들이 각각 검색 결과 조각을 만들어 내고 이를 통합해서 하나의 결과로 합쳐서 응답하도록 설계돼 있다.(세그먼트 단위 검색) 세그먼트는 색인된 데이터가 역색인 구조로 저장되어 있다.

세그먼트를 관리하기 위한 용도로 커밋 포인트라는 자료구조가 있고 커밋 포인트는 여러 세그먼트의 목록 정보를 가지고 있고 검색 요청시 이를 적극적으로 활용한다.

색인 작업 요청이 들어오면 색인 작업이 이뤄지고 하나의 세그먼트가 생성된다. 그리고 색인 작업이 추가로 요청될 때마다 새로운 세그먼트가 추가로 생성되고 커밋 포인트에 기록된다.  너무 많은 세그먼트가 생성되면 읽기 성능이 저하될 수 있기 때문에 백그라운드에서 주기적으로 세그먼트 파일을 merge 하는 작업을 수행하고 이를 통해 모든 세그먼트를 물리적으로 하나의 파일로 병합한다.

기본저긍로 한번 디스크에 저장된 세그먼트는 수정이 불가능하도록 특별히 관리된다. 주기적인 merge 작업에 의해 세그먼트가 통합되고 삭제되기 전까지는 전혀 수정을 허용하지 않는다. 수정을 전혀 허용하지 않기 때문에 색인 작업이 수행될 때마다 세그먼트가 추가로 생성될 수 밖에 없다.

### 세그먼트 불변성
세그먼트의 수정을 허용하지 않기 때문에 불변성을 가진다. 

[불변성의 장점]
* 동시성 문제를 회피할 수 있다 : 불변성이 보장된다면 Lock이 필요없어 진다.
* 시스템 캐시를 적극적으로 활용할 수 있다 : 불변성이 보장되지 않는다면 데이터가 변경될 때마다 캐시를 삭제하고 다시 생성해야한다.
* 높은 캐시 적중률을 유지할 수 있다 : 시스템 캐시의 수명이 길어진다.
* 리소스를 절감할 수 있다

### 세그먼트 불변성과 업데이트
수정 연산의 경우 세그먼트의 불변성을 유지하기 위해 해당 데이터를 삭제한 후 다시 추가하는 방식으로 동작한다. 

삭제 연산은 단순히 데이터를 삭제하는 것이 아니다. 모든 문서에는 삭제 여부를 표시하는 비트 배열이 내부적으로 존재하고, 삭제 요청이 들어오면 대상 데이터의 비트 배열을 찾아 삭제 여부만 표시하고 끝낸다.

삭제될 데이터가 실제 물리적으로 삭제되는 시점은 백그라운드에서 주기적으로 일어나는 merge 작업이 수행될 때다.

### 루씬을 위한 Flush, Commit, Merge
루씬은 효율적인 색인 작업을 위해 내부적으로 일정 크기의 버퍼를 가지고 있다. (인메모리 버퍼) 버퍼가 없다면 데이터가 들어올때마다 매번 세그먼트를 만들어야 하고, 대량 데이터가 빠르게 요청될 경우 지연이 발생할 수밖에 없다. 

루씬에 색인 작업이 요청되면 데이터는 일단 인메모리 버퍼에 순서대로 쌓이고, 내부 버퍼에 일정 크기 이상 데이터가 쌓이거나 일정 시간이 흐를 경우 버퍼에 쌓인 데이터를 모아 한꺼번에 처리한다. 

버퍼에 모여 한번에 처리된 데이터는 세그먼트 형태로 생성되고 즉시 디스크로 동기화된다. 이러한 인메모리 버퍼 기반의 처리 과정을 Flush라고 부른다. 

루씬에서 물리적으로 디스크에 기록을 수행하는 fsync() 함수를 호출하는 작업을 commit이라고 한다. 위에서 말한것처럼 다수의 세그먼트를 하나로 합치는 작업은 merge라고 한다. 

[merge의 장점]
* 검색 성능이 좋아진다
* 세그먼트가 차지하는 디스크 용량이 줄어든다

하지만 merge를 하기 위해서는 Commit 작업을 반드시 동반해야 하는데 Commit 작업은 비용이 매우 많이 드는 작업이다. 따라서 적절한 주기를 설정하는 것이 매우 중요하다. 

### 엘라스틱서치를 위한 Refresh, Flush, Optimize API
* Refresh : 엘라스틱서치는 대용량 데이터를 색인하고 실시간 검색을 할 수 있게 설계되어 있다. 실시간 검색에 가깝게 동작하기 때문에 주기적으로 인메모리 버퍼에 대해 flush 작업을 수행한다. 이러한 flush 작업을 엘라스틱서치에서는 Refresh라고 부르며 모든 샤드에서는 기본적으로 1초에 한 번씩 Refresh 작업이 수행된다. 
* Flush : Flush는 루씬의 Commit 작업을 수행하고 새로운 Translog를 시작한다는 의미다. (루씬에서 제공하는 Flush 작업과는 다르다!) Translog는 샤드의 장애 복구를 위해 제공되는 특수한 파일이다. 샤드는 자신에게 일어나는 모든 변경사항을 Translog에 먼저 기록한 후 내부에 존재하는 루씬을 호출한다. 루씬 Commit이 정상적으로 수행되면 Translog 파일에서 Commit이 정상적으로 일어난 시점까지의 내역이 비로소 삭제된다.
* Optimize API : 루씬 Merge 작업을 강제로 수행하는 기능이다.

### 엘라스틱서치와 NRT(실시간에 가까운)
472p

## 9.4 고가용성을 위한 Translog의 비밀
엘라스틱서치는 분산 시스템이 지원해야 하는 고가용성을 제공하기 위해 내부적으로 Translog라는 특수한 형태의 파일을 유지하고 관리하고 있다. 장애 복구를 위한 백업 데이터 및 데이터 유실 방지를 위한 저장소로써 Translog를 적극 활용하고 있다.

### Translog의 동작 순서
샤드에 어떤 변경사항이 생길 경우 Translog 파일에 먼저 해당 내역을 기록한 후 내부에 존재하는 루씬 인덱스로 데이터를 전달한다. 루씬으로 전달된 데이터는 인메모리 버퍼로 저장되고 주기적으로 처리되어 결과적으로 세그먼트가 된다.

Refresh 작업이 일어나더라도 Translog 파일에 기록된 내용은 삭제되지 않고 계속 유지된다. 이러한 특성을 이용해 엘라스틱서치는 Translog의 내역을 바탕으로 장애 발생시 복구 작업을 수행할 수 있다.

Translog의 내용이 삭제되는 시점은 Flush 작업이 성공적으로 마무리되고 물리적으로 디스크 동기화에 성공하면 누적돼 있던 Translog 파일의 내용이 비로소 삭제된다.

### Translog가 존재하는 이유
가장 큰 목적은 장애 복구를 위해서다. (474~476p)

## 9.5 엘라스틱서치 샤드 최적화
시간이 흐를수록 데이터의 크기는 점점 더 커진다. 분산 시스템의 경우 이론상 데이터가 무한대로 증가할 수 있기 때문에 최적화의 필요성이 더욱더 커진다.

### 운영 중에 샤드의 개수를 수정하지 못하는 이유
인덱스를 생성할 때 설정된 샤드의 개수는 절대 변경이 불가능하기 때문에 데이터의 크기가 최대 얼마까지 증가할 것인지를 잘 계상해서 최초 인덱스를 생성할 때 샤드의 개수를 신중하게 결정해야 한다.

* 프라이머리 샤드 : 실제 서비스가 일어나는 샤드다. 실질적인 CRUD를 제공하는 샤드로서 엘라스틱서치를 구성하는 핵심 요소다.
* 레플리카 샤드 : 장애 복구를 위해 존재하는 샤드다. 프라이머리 샤드와 동일한 데이터를 가지고 있기 때문에 평상시에는 읽기 분산에 활용된다.

기존의 샤드의 갯수를 수정하지 못하는 이유는 엘리스틱서치 샤드는 루씬 인덱스의 확장이다. 각 샤드는 내부에 독립적인 루씬 라이브러리를 가지고 있으며 루씬은 단일 머신 위에서만 동작하는 검색엔진이다. 이러한 특성때문에 샤드 내부의 루씬 입장에서는 함께 인덱스를 구성하는 다른 샤드의 존재를 눈치채지 못한다.

### 레플리카 샤드의 복제본 수는 얼마가 적당할까?
레플리카 샤드의 복제본 수는 운영 중에도 얼마든지 변경 가능하다. 복제본 수를 지정함으로써 모든 프라이머리 샤드가 복제되기 때문에 클러스터 내부에서 운영하고 있는 전체 샤드 개수를 고려해서 적절한 복제본 세트를 운영해야 한다. 

### 클러스터에서 운영 가능한 최대 샤드 수는?
인덱스 생성시 기본값으로 5개의 프라이머리 샤드와 1개의 레플리카 복제본을 생성한다. 때무에 인덱스 생성시 최소 10개의 샤드가 클러스터 내부에 생성된다. 

엘라스틱서치 클러스터에서 운영 가능한 전체 샤드수에 대한 특별한 제한은 없지만 개별 인덱스 생성시 설정 가능한 샤드의 수는 1024개로 제한되어 있다.

* 클러스터에서 존재하는 모든 샤드는 마스터 노드에서 관리된다. 그래서 샤드가 많아질수록 마스터 노드의 부하도 덩달아서 증가한다. 그러므로 너무 많은 샤드로 인해 마스터 노드의 메모리가 부족해지지 않도록 주의해야 한다.
* 샤드 1개가 물리적으로 5GB를 넘지 않도록 권장한다.

### 하나의 인덱스에 생성 가능한 최대 문서 수는?
하나의 샤드에서 색인할 수 있는 문서 수가 대략 20억 개 정도이고 인덱스는 최대 1024개까지의 샤드를 가질 수 있기 때문에 이론적으로 개별 인덱스가 가질 수 있는 최대 문서 수는 약 2조개라고 생각하면 된다.

### 엘라스틱서치에서 Compressed OOP 사용하기
최신 JDK에서는 Compressed OOP가 기본 설정으로 동작하기 때문에 단순히 힙 크기를 32GB 이하로 설정하기만 하면 된다.

* Zero-Based Compressed OOP : JVM이 시작될 때 힙 메모리의 시작 번지가 0번지부터 시작되도록 논리적으로 강제한다. 이를 통해 Compressed OOP가 객체의 포인터를 빠른 성능의 시프트 연산만으로도 계산할 수 있게 할 수 있는 것이다.

## 10.3 엘라스틱서치와 가상 메모리
현대 운영체제에서는 애플리케이션이 물리 메모리를 직접적으로 할당받지 못한다. 운영체제는 멀티태스킹 실현을 위해 각 애플리케이션을 위한 전용 가상 메모리를 만들고 이를 할당한다.
가상 메모리를 할당받은 애플리케이션은 자신이 할당받은 가상 메모리를 실제 물리 메모리로 착각하고 사용하는 것이다.

### 가상 메모리
가상 메모리는 애플리케이션에서 물리적인 메모리보다 많은 양의 메모리를 사용할 수 있도록 운영체제가 제공하는 대표적인 메모리 관리 기술이다. 즉 물리적인 메모리 번지를 직접 할당해서 메모리 공간을 제공하는 것이 아니라 가상의 메모리 번지를 생성해서 제공함으로써 애플리케이션 별로 전용 메모리 공간을 사용할 수 있도록 제공하는 메모리 관리 기법이다.

### JVM을 위한 가상 메모리
자바 애플리케이션은 JVM 위에서 실행되고 실행시 옵션으로 힙 크기를 설정할 수 있다. -Xms 옵션은 처음 시작시의 힙 크기를 설정하는 옵션이고 -Xmx 옵션은 최대로 할당 가능한 힙 크리를 설정하는 옵션이다.

프로그램이 동작하던 중 메모리가 부족해지면 2GB까지 힙 크기가 자동으로 늘어난다. 

### 엘라스틱서치를 위한 vm.max_map_count 설정
518~520p

