# 9. 엘라스틱서치와 루씬 이야기
## 9.1 클러스터 관점에서 구성요소 살펴보기
엘라스틱서치는 기본적으로 클러스터라는 단위로 데이터를 제공한다. 클러스터는 하나 이상의 물리적인 노드로 이뤄져 있으며 각 노드는 모두 데이터 색인 및 검색 기능을 제공하는 일종의 물리적인 서버이기도 하다. 내부에는 루씬 라이브러리가 자리 잡고 있고, 이는 엘라스틱서치의 근간을 이루는 핵심 모듈이다.

1. 클러스터 : 데이터를 실제로 가지고 있는 __노드의 모음__ 이다. 엘라스틱서치에서는 관련된 모든 노드들을 논리적으로 확장해서 클러스터라고 부른다. 같은 클러스터 내에서만 데이터 공유가 가능하기 때문에 연관된 모든 노드는 하나의 클러스터에서 구성원으로 연결되는 것이 매우 중요하다.
2. 노드 : 물리적으로 실행된 런타임 상태의 엘라스틱서치를 노드라고 부른다. 노드는 논리적인 클러스터를 이루는 구성원의 일부이며 실제 데이터를 물리적으로 가지고 있는 단일 서버이기도 하다. 노드는 내부에 다수의 인덱스를 가지고 있고, 각 인덱스는 다수의 문서를 가지고 있다. 
   * 마스터 노드 - 클러스터의 제어 담당
   * 데이터 노드 - 데이터를 보유하고 CRUD, 검색, 집계 등 데이터 관련 작업 담당
   * 인제스트 노드 - 색인 전 전처리 작업 담당
   * 트라이브 노드 - 여러 클러스터를 제한적으로 연결해서 동시에 검색 수행 (특수한 목적의 노드)
   * 코디네이팅 노드 - 검색, 집계시 분산 처리만을 목적으로 설정된 노드
3. 인덱스 : 유사한 특성을 가지고 있는 문서를 모아둔 문서들의 컬렉션이다. 예) 고객정보, 상품정보, 주문정보 등 클러스터 내에서 `유일한 인덱스명`을 가져야 한다. 또한 인덱스명은 모두 `소문자`로 설정해야 한다.
4. 문서 : 검색 대상이 되는 실제 물리적인 데이터를 뜻한다. 엘라스틱서치에서는 JSON 형식으로 표현된다.
5. 샤드 : 인덱스에는 매우 __많은 양의 문서__ 가 저장될 수 있다. __물리적인 한계를 뛰어넘기 위해 나온 개념이 샤드이다.__ 이를 이용하면 데이터를 분산 저장하는 방식으로 손쉬운 수평 확장이 가능해진다. 인덱스 생성시 기본적으로 5개의 샤드로 데이터가 분산되도록 생성된다.
6. 레플리카 : 샤드의 복제본을 나타낸다. 인덱스 생성시 기본적으로 1개의 레플리카 세트를 생성한다. 검색시 레플리카가 적극적으로 활용되기 때문이 이를 이용하면 읽기 분산에 유리해진다. 인덱스 생성시 샤드수, 레플리카 개수를 자유롭게 설정할 수 있다. 단 인덱스 생성후 변경하는 것이 불가능하다. 
7. 세그먼트 : 샤드 내부에는 루씬 라이브러리를 포함하고 있는데, 이를 이용해 대부분의 검색 기능을 제공한다. 루씬에 데이터가 색인되면 데이터는 최소한의 단위인 토큰으로 분리되고 특수한 형태의 자료구조로 저장되는데 이런 자료구조를 세그먼트라고 한다. `세그먼트는 읽기에 최적화된 자료구조로서 역색인이라는 특수한 형태로 변환되어 물리적인 디스크에 저장된다.`

## 9.2 엘라스틱서치 샤드 VS 루씬 인덱스
457~459p

## 9.3 엘라스틱서치가 근실시간 검색을 제공하는 이유
엘라스틱서치는 처음부터 다양한 데이터의 색인이 가능하고 근실시간 검색을 제공하는 것을 목표로 개발됐다.

### 색인 작업시 세그먼트의 기본 동작 방식
하나의 루씬 인덱스는 내부적으로 다수의 세그먼트로 구성돼 있다. 

루씬은 검색 요청을 받으면 다수의 작은 세그먼트 조각들이 각각 검색 결과 조각을 만들어 내고 이를 통합해서 하나의 결과로 합쳐서 응답하도록 설계돼 있다.(세그먼트 단위 검색) 세그먼트는 색인된 데이터가 역색인 구조로 저장되어 있다.

세그먼트를 관리하기 위한 용도로 커밋 포인트라는 자료구조가 있고 커밋 포인트는 여러 세그먼트의 목록 정보를 가지고 있고 검색 요청시 이를 적극적으로 활용한다.

색인 작업 요청이 들어오면 색인 작업이 이뤄지고 하나의 세그먼트가 생성된다. 그리고 색인 작업이 추가로 요청될 때마다 새로운 세그먼트가 추가로 생성되고 커밋 포인트에 기록된다.  너무 많은 세그먼트가 생성되면 읽기 성능이 저하될 수 있기 때문에 백그라운드에서 주기적으로 세그먼트 파일을 merge 하는 작업을 수행하고 이를 통해 모든 세그먼트를 물리적으로 하나의 파일로 병합한다.

기본저긍로 한번 디스크에 저장된 세그먼트는 수정이 불가능하도록 특별히 관리된다. 주기적인 merge 작업에 의해 세그먼트가 통합되고 삭제되기 전까지는 전혀 수정을 허용하지 않는다. 수정을 전혀 허용하지 않기 때문에 색인 작업이 수행될 때마다 세그먼트가 추가로 생성될 수 밖에 없다.

### 세그먼트 불변성
세그먼트의 수정을 허용하지 않기 때문에 불변성을 가진다. 

[불변성의 장점]
* 동시성 문제를 회피할 수 있다 : 불변성이 보장된다면 Lock이 필요없어 진다.
* 시스템 캐시를 적극적으로 활용할 수 있다 : 불변성이 보장되지 않는다면 데이터가 변경될 때마다 캐시를 삭제하고 다시 생성해야한다.
* 높은 캐시 적중률을 유지할 수 있다 : 시스템 캐시의 수명이 길어진다.
* 리소스를 절감할 수 있다

### 세그먼트 불변성과 업데이트
수정 연산의 경우 세그먼트의 불변성을 유지하기 위해 해당 데이터를 삭제한 후 다시 추가하는 방식으로 동작한다. 

삭제 연산은 단순히 데이터를 삭제하는 것이 아니다. 모든 문서에는 삭제 여부를 표시하는 비트 배열이 내부적으로 존재하고, 삭제 요청이 들어오면 대상 데이터의 비트 배열을 찾아 삭제 여부만 표시하고 끝낸다.

삭제될 데이터가 실제 물리적으로 삭제되는 시점은 백그라운드에서 주기적으로 일어나는 merge 작업이 수행될 때다.

### 루씬을 위한 Flush, Commit, Merge
루씬은 효율적인 색인 작업을 위해 내부적으로 일정 크기의 버퍼를 가지고 있다. (인메모리 버퍼) 버퍼가 없다면 데이터가 들어올때마다 매번 세그먼트를 만들어야 하고, 대량 데이터가 빠르게 요청될 경우 지연이 발생할 수밖에 없다. 

루씬에 색인 작업이 요청되면 데이터는 일단 인메모리 버퍼에 순서대로 쌓이고, 내부 버퍼에 일정 크기 이상 데이터가 쌓이거나 일정 시간이 흐를 경우 버퍼에 쌓인 데이터를 모아 한꺼번에 처리한다. 

버퍼에 모여 한번에 처리된 데이터는 세그먼트 형태로 생성되고 즉시 디스크로 동기화된다. 이러한 인메모리 버퍼 기반의 처리 과정을 Flush라고 부른다. 

루씬에서 물리적으로 디스크에 기록을 수행하는 fsync() 함수를 호출하는 작업을 commit이라고 한다. 위에서 말한것처럼 다수의 세그먼트를 하나로 합치는 작업은 merge라고 한다. 

[merge의 장점]
* 검색 성능이 좋아진다
* 세그먼트가 차지하는 디스크 용량이 줄어든다

하지만 merge를 하기 위해서는 Commit 작업을 반드시 동반해야 하는데 Commit 작업은 비용이 매우 많이 드는 작업이다. 따라서 적절한 주기를 설정하는 것이 매우 중요하다. 

### 엘라스틱서치를 위한 Refresh, Flush, Optimize API
* Refresh : 엘라스틱서치는 대용량 데이터를 색인하고 실시간 검색을 할 수 있게 설계되어 있다. 실시간 검색에 가깝게 동작하기 때문에 주기적으로 인메모리 버퍼에 대해 flush 작업을 수행한다. 이러한 flush 작업을 엘라스틱서치에서는 Refresh라고 부르며 모든 샤드에서는 기본적으로 1초에 한 번씩 Refresh 작업이 수행된다. 
* Flush : Flush는 루씬의 Commit 작업을 수행하고 새로운 Translog를 시작한다는 의미다. (루씬에서 제공하는 Flush 작업과는 다르다!) Translog는 샤드의 장애 복구를 위해 제공되는 특수한 파일이다. 샤드는 자신에게 일어나는 모든 변경사항을 Translog에 먼저 기록한 후 내부에 존재하는 루씬을 호출한다. 루씬 Commit이 정상적으로 수행되면 Translog 파일에서 Commit이 정상적으로 일어난 시점까지의 내역이 비로소 삭제된다.
* Optimize API : 루씬 Merge 작업을 강제로 수행하는 기능이다.

### 엘라스틱서치와 NRT(실시간에 가까운)
472p
