# 3. 엔티티
## 01. 엔티티 클래스
엔티티는 DB 테이블에 보관할 대상이 된다. EntityManager를 사용해서 엔티티 단위로 저장하고 조회하고, 삭제한다. 

JPA에서 엔티티 설정 방법은 @Entity 애노테이션을 사용하는 방식과 XML 매핑 설정 사용하는 방식이 있다. (주로 @Entity 사용)

### @Entity 애노테이션과 @Table 애노테이션
EntityManager는 @Entity 애노테이션을 적용한 클래스를 이용해서 SQL 쿼리를 생성할 때 클래스 이름을 테이블 이름으로 사용한다. DBMS가 테이블 이름의 대소문자를 구분하거나 클래스 이름과 테이블 이름이 다를 경우 @Table 애노테이션을 사용해서 테이블 이름을 직접 지정할 수 있다.

### @Id 애노테이션
엔티티는 식별자를 갖는다. 이 식별자를 설정하기 위해서 @Id를 사용한다.

@Id는 필드에 적용할수도 있고(모든 필드가 매핑 대상이 됨), getter 메서드에도 적용할 수 있다.(모든 자바빈 메서드 형식의 프로퍼이가 매핑 대상이 됨)

보통 DB 테이블의 주요키 컬럼에 매핑할 대상에 적용하지만 반드시 그래야하는 것은 아니다. 하지만 EntityManager.find(id)에는 @Id를 지정한 필드를 사용해야 한다.

### @Basic 애노테이션과 지원 타입
@Id 애노테이션을 적용한 대상을 제외하고 나머지 영속 대상은 @Basic 애노테이션을 이용해서 설정한다.(생략 가능)

* int, long 등 자바 기본 데이터 타입
* Integer, Long 등 기본 데이터 타입에 대응하는 래퍼 타입
* BigInteger, BigDecimal
* String
* Date, Calendar
* Date, Time, Timestamp
* enum
* byte[], Byte[], char[], Character[]
위 타입의 경우에는 @Basic 애노테이션을 생략할 수 있다. 

날짜와 시간 타입은 @Temporal 애노테이션과 함께 사용한다. 프로퍼티가 어떤 SQL 타입에 매핑되느냐에 따라 알맞은 TemporalType을 값으로 설정한다.
* DATE
* TIME
* TIMESTAMP

`JPA 2.1의 경우 자바8 이전에 나온 관계로 LocalDateTime을 지원하지 않는다. 자바8 이후를 사용할 수 있는 경우에는 LocalDateTime 타입을 사용하여 날짜를 매핑할 수 있다.`

열거 타입의 경우 @Enumerated 애노테이션을 사용한다. EnumType.STRING을 사용해서 매핑된 칼럼이 열거 타입의 상수 이름을 값으로 가질수 있게 한다. 상수 이름 대신 인덱스를 저장하고 싶은 경우 EnumType.ORDINAL 을 사용한다. __상수 순서는 유지보수 과정에서 변경될 수 있으므로 상수의 순서보다는 이름을 사용하도록 하자__

### @Column 애노테이션과 이름 지정
필드/프로퍼티의 이름과 테이블의 칼럼 이름이 다를 경우 사용한다. 

### @Column 애노테이션을 이용한 읽기 전용 매핑
@Column 애노테이션을 사용하면 변경 내역이 DB에 반영되지 않는 읽기 전용 데이터를 설정할 수 있다. `@Column(name="id", insertable=false, updatable=false)` insertable 속성이 false이면 엔티티 객체를 DB에 저장할 때 insert 쿼리에서 해당 값을 제외한다. updatable 속성이 false이면 update 쿼리의 수정 대상에서 제외된다.


## 02. 접근타입 : 영속 대상 필드와 프로퍼티
엔티티 객체를 매핑할 때 필드가 아닌 자바빈 방식의 프로퍼티 메서드 중 get 메서드에서도 설정할 수 있다.

```java
@Id
public String getNumber() {
    return number;
}

public void setNumber(String number) {
    this.number = number;
}
```
필드가 아닌 get 메서드에 @Id 애노테이션을 설정하면 JPA는 필드 대신 get/set 메서드를 이용해서 데이터를 처리한다. DB에서 데이터를 읽어와 엔티티 객체에 전달할 때는 set 메서드를 이용하고, 엔티티를 DB에 반영할 때는 get 메서드를 이용해서 엔티티에서 값을 읽어온다. 따라서 프로퍼티 접근 타입을 사용할 경우 get/set 메서드를 모두 정의해야 한다.

```java
// 1. 기본적으로 필드 접근 방식을 사용하고 특정 영속 대상에만 프로퍼티 접근 방식을 사용해야 하는 경우 @Access 애노테이션을 사용
@Id
private String number;

@Column(name="id")
@Access(AccessType.PROPERTY)
private Long dbId;

// 2. 프로퍼티 접근 타입을 기본으로 사용하고 특정 영속 대상만 필드 접근 타입을 사용하는 경우 get 메서드에 @Access 애노테이션 설정

private Long dbId;

@Id
public String getNumber() {
    return number;
}

public void setNumber(String number) {
    this.number = number;
}

@Column(name="id")
@Access(AccessType.FIELD)  //접근 타입이 필드이므로 setDbId() 메서드를 사용하지 않는다.
public Long getDbId() {
    return dbId;
}
```

### 영속 대상에서 제외하기
필드 접근 타입을 사용하는데 영속 대상이 아닌 필드가 존재한다면 `transient` 키워드를 사용해서 영속 대상에서 제외할 수 있다.(또는 @Transient)


