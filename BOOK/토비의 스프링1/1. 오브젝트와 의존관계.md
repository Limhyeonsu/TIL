# 1. 오브젝트와 의존관계
스프링은 자바를 기반으로 한 기술로 가장 중요하게 가치를 두는 것이 바로 객체지향 프로그래밍이 가능하다는 것이다.

그래서 스프링을 이해하기 위해서는 `오브젝트`에 깊은 관심을 가져야 한다. 애플리케이션에서 오브젝트가 생성되고, 다른 오브젝트와 관계를 맺고 사용되고 소멸하기까지의 전 고정을 진지하게 생각해볼 필요가 있다.

오브젝트에 대한 관심은 기술적인 특징과 사용 방법을 넘어서 오브젝트 설계로 발전하게 된다. 

스프링은 오브젝트를 어떻게 효과적으로 설계하고 구현하고, 사용하고 이를 개선해나갈 것인가에 대한 명괘한 기준을 마련해준다.

## 1.1 초난감 DAO
54~59p

## 1.2 DAO의 분리
### 관심사의 분리
사용자의 비즈니스 프로세스와 그에 따른 요구사항은 끊임없이 바뀌고 발전한다. 애플리케이션이 기반을 두고 있는 기술도 시간이 지남에 따라 바뀌고, 운영되는 환경도 변화한다.

그래서 개발자가 객체를 설계할 떄 가장 염두에 둬야 할 사항은 바로 미래의 변화를 어떻게 대비할 것인가이다.

객체지향 설계와 프로그래밍이 이전의 절차적 프로그래밍 패러다임에 비해 초기에 좀 더 많은, 번거로운 작업을 요구하는 이유는 객체지향 기술 자체가 지니는 변화에 효과적으로 대처할 수 있다는 기술적인 특징 때문이다.

객체지향 기술은 실세계를 최대한 가깝게 모델링해낼 수 있고, 가상의 추상세계 자체를 효과적으로 구성할 수 있고, 이를 자유롭고 편리하게 변경, 발전, 확장시킬 수 있다는데 의미가 있다.

미래를 준비하는 데 있어 가장 중요한 과제는 변화에 어떻게 대비할 것인가이다. `가장 좋은 대책은 변화의 폭을 최소한으로 줄여주는 것이다.`

어떻게 변경이 일어날 때 필요한 작업을 최소화하고, 그 변경이 다른 곳에 문제를 일으키지 않게 할 수 있을까? 그것은 `분리와 확장을 고려한 설계가 있었기 때문이다.` 모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다. 문제는 변화는 대체로 한 가지 관심에서 일어나지만 그에 따른 작업은 한곳에 집중되지 않는 경우가 많다. 그러므로 우리가 준비할 일은 __한 가지 관심이 한 군데에 집중되게 하는 것이다. 즉 관심이 같은 것끼리 모으고, 관심이 다른것은 따로 떨어져 있게 하는 것이다.__

__관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고, 관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것이라 생각할 수 있다.__

### 커넥션 만들기의 추출
UserDao의 관심사항
```java
public class UserDao {

    public void add(User user) {
        //1. DB 커넥션 연결
        
        //2. SQL을 담을 Statement 만들고 실행
        
        //3. 작업이 끝난 Statement와 Connection 종료
    }
    
    public User get(String id) {
        //1. DB 커넥션 연결
        
        //2. SQL을 담을 Statement 만들고 실행
        
        //3. 작업이 끝난 Statement와 Connection 종료
    }
}
```
add(), get() 메서드에 중복된 코드가 발생한다. 이렇게 하나의 관심사가 방만하게 중복되어 있고, 여기저기 흩어져 있어서 다른 관심의 대상과 얽혀있으면 변경이 일어날 때 엄청난 고통을 일으키는 원인이 된다.

* 중복 코드의 메서드 추출 : 가장 먼저 커넥션을 가져오는 중복된 코드를 분리한다. getConnection()이라는 독립된 메서드로 만들고 각 DAO 메서드에서 getConnection() 메서드를 호출해서 DB 커넥션을 가져오게 만든다.
* 변경사항에 대한 검증(리팩토링과 테스트) : 변경된 UserDao의 기능이 변경하기 전과 동일한지 확인하기 위해 앞서 만든 테스트 코드를 실행하여 확인하면 된다.

위 작업은 기능에는 영향을 주지 않으면서 코드의 구조만 변경한다. 이러한 작업을 `리팩토링`이라고 한다. 그리고 getConnection() 메서드 처럼 공통의 기능을 담당하는 메서드로 중복된 코드를 뽑아내는 것을 리팩토링에서 `메서드 추출` 기법이라고 한다. 

### DB 커넥션 만들기의 독립
예) UserDao 클래스를 타 업체에 판매한다고 할 때 getConnection() 메서드는 업체마다 사용하는 DB가 달라 변경이 필요할 수 있다. 이때 유연하게 DB 별로 getConnection()을 사용하는 방법으로 기존 UserDao 코드를 한 단계 더 분리하여 추상메서드로 만든다.

추상클래스인 UserDao를 구입한 업체에서 추상메서드인 getConnection()을 상속받아 구현한다면 UserDao get(), add() 메서드에서 상용하는 getConnection() 메서드를 문제없이 사용할 수 있다.

이렇게 기본적인 로직의 흐름을 만들고 그 기능의 일부를 추상 메서드나 오버라이딩이 가능한 protected 메서드 등으로 만든 뒤 서브클래스에서 이런 메서드를 필요에 맞게 구현해서 사용하도록 하는 방법을 디자인 패턴에서 `템플릿 메서드 패턴`이라고 한다. (템플릿 메서드 패턴 - 변하지 않는 기능은 슈퍼클래스에 만들어두고, 자주 변경되며 확장할 기능은 서브클래스에서 만들도록 한다.)

UserDao의 getConnection() 메서드는 Connection 타입 오브젝트를 생성한다는 기능을 정의해놓은 추상 메서드이다. 그리고 UserDao의 서브클래스의 getConnection() 메서드는 어떤 Connection 클래스의 오브젝트를 어떻게 생성할 것인지를 결정하는 방법이라고도 볼 수 있다. __이렇게 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것을 `팩토리 메서드 패턴`이라고 한다.__ (팩토리 메서드 패턴 - 슈퍼 클래스에서 서브 클래스에서 구현한 메서드를 호출해서 필요한 타입의 오브젝트를 가져와 사용, 서브클래스에서 어떤 클래스의 오브젝트를 만들어 리턴할지 슈퍼클래스에서는 알지 못함)모두 같은 종류의 Connection 구현 클래스의 오브젝트를 리턴할 수도 있는데 오브젝트의 생성 방식이 다르다면, 이는 팩토리 메서드 패턴으로 이해할 수 있다.

템플릿 메서드 패턴, 팩토리 메서드 패턴을 사용하여 관심사를 분리하는 방법은 간단하면서 효과적이나 이 방법은 상속을 사용한다는 단점이 있다. 자바는 다중상속을 허용하지 않고, 상속을 통한 상하위 클래스의 관계는 많이 밀접하다. 따라서 상속관계는 다른 관심사에 대해 긴밀한 결합을 허용한다. 슈퍼클래스 내부의 변경이 생기면 모든 서브클래스를 함께 수정하거나 다시 개발해야 할 수도 있다.

## 1.3 DAO의 확장
### 클래스의 분리
위에서는 관심사를 분리할 때 1)독립된 메서드를 만들어서 분리, 2)상하위 클래스로 분리 했다. 

상속관계가 아닌 아예 독립된 클래스로 만드는 방법이 있다. 별도로 만든 클래스를 UserDao가 이용하게 한다.
```java
public class UserDao {
    private SimpleConnectionMaker simpleConnectionMaker;
    
    public UserDao() {
        simpleConnectionMaker = new SimpleConnectionMaker();
    }
    
    public void add(User user) {
        Connection c = simpleConnectionMaker.makeNewConnection();
        //...
    }
    
    public User get(String id) {
        Connection c = simpleConnectionMaker.makeNewConnection();
        //...
    }

}

```
이렇게 클래스를 분리하는 경우에도 상속을 이용했을때처럼 자유로운 확장이 가능하게 하려면 두가지 문제를 해결해야 한다. 1)여러 타 업체에서 다른 DB를 사용하는 경우 커넥션을 가져오는 코드를 일일히 변경해야한다. 2)DB 커넥션을 제공하는 클래스가 어떤것인지 UserDao가 구체적으로 알고 있어야 한다.

이런 문제의 원인은 UserDao가 DB 커넥션을 가져오는 구체적인 방법에 종속되기 때문이다. 

### 인터페이스의 도입
UserDao가 DB 커넥션을 가져오는 구체적인 방법에 종속되는 문제는 중간에 추상적인 느슨한 연결고리를 만들어서 해결할 수 있다.(추상화: 어떤 것들의 공통적인 성격을 뽑아내어 이를 따로 분리해내는 작업)

자바에서 추상화를 위해 제공하는 유용한 도구는 바로 인터페이스다. 인터페이스로 추상화해놓은 최소한의 통로를 통해 접근하는 쪽에서 오브젝트를 만들때 사용할 클래스가 무엇인지 몰라도 된다. 인터페이스를 통해 접근하게 하면 실제 구현 클래스를 바꿔도 신경 쓸 일이 없다.

UserDao가 인터페이스를 사용한다면 인터페이스의 메서드를 통해 알 수 있는 기능에만 관심을 가지면 되지, 그 기능을 어떻게 구현했는지에는 관심을 둘 필요가 없다.

```java
public interface ConnectionMaker {
    public Connection makeConnection() throw ClassNotFoundException, SQLException;
}

public class UserDao {
    private ConnectionMaker connectionMaker;
    
    public UserDao() {
        //여전히 어떤 클래스의 오브젝트를 사용할지 정해야한다.
        connectionMaker = new AConnectionMaker();
    }
    
    public void add(User user) {
        Connection c = connectionMaker.makeConnection();
        //...
    }
    
    public User get(String id) {
        Connection c = connectionMaker.makeConnection();
        //...
    }

}

```

### 관계설정 책임의 분리
위 처럼 인터페이스를 사용하여도 여전히 어떤 클래스의 오브젝트를 사용할지 정해야한다는 문제가 있다. 그 이유는 UserDao안에 분리되지 않은 또 다른 관심사항이 존재하고 있기 때문이다.
UserDao 안에 어떤 ConnectionMaker 구현 클래스를 사용할지 결정하는 부분을 분리하지 않으면 UserDao는 결코 독립적으로 확장 가능한 클래스가 될 수 없다.

따라서 UserDao를 사용하는 클라이언트 오브젝트에서 UserDao를 사용하기 전에 ConnectionMaker 구현 클래스를 어떤 것을 사용할지 결정하도록 만들어보자. (오브젝트와 오브젝트 사이의 관계 설정)

외부에서 만든 오브젝트를 전달받기 위해 메서드 파라미터나 생성자 파라미터를 이용하면 된다. 이때 파라미터 타입이 인터페이스라면 해당 인터페이스를 구현한 클래스는 어떤 것이든 상관없이 전달 받을 수 있다.

UserDao 오브젝트가 동작하기 위해서는 특정 클래스의 오브젝트와 관계를 맺어야 한다. 하지만 클래스 사이에 관계가 만들어진 것은 아니고 단지 오브젝트 사이에 다이내믹한 관계가 만들어지는 것이다. 

코드에서 특정 클래스를 전혀 알지 못하더라도 해당 클래스가 구현한 인터페이스를 사용했다면 그 클래스의 오브젝트를 인터페이스 타입으로 받아서 사용할 수 있다.`(다형성)`

클라이언트는 자기가 UserDao를 사용해야하기 때문에 ConnectionMaker의 구현 클래스를 선택하고, 선택한 클래스의 오브젝트를 생성해서 UserDao와 연결해줄 수 있다. 기존 UserDao에서는 생성자에게 이 책임이 있었다.

```java
public class UserDao {
    private ConnectionMaker connectionMaker;
    
    public UserDao(ConnectionMaker connectionMaker) {
        this.connectionMaker = connectionMaker;
    }

    //...    

}

```

이렇게 하면 UserDao를 전혀 손대지 않고 모든 고객이 만족스럽게 DB 연결 기능을 확장해서 사용할 수 있게 된다.

인터페이스를 사용하는 방법은 상속을 사용한 방법에 비해 훨씬 유연하다. 

### 원칙과 패턴
* 개방 폐쇄 원칙 : 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다. 예)UserDao는 DB 연결 방법이라는 기능을 확장하는데는 열려있다. 동시에 핵심 기능을 구현한 코드는 그런 변화에 영향을 받지 않으므로 변경에는 닫혀있다. 인터페이스를 사용해 확장 기능을 정의한 대부분의 API는 이 개방 폐쇄 원칙을 따른다고 볼 수 있다.
* 높은 응집도와 낮은 결합도 : 
  * 높은 응집도란 하나의 모듈, 클래스가 하나의 책임(관심사)에만 집중되어 있다는 뜻이다. 따라서 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다는 것으로 설명할 수도 있다. 변경이 필요할 때 모듈의 많은 부분이 바뀐다면 응집도가 높다고 할 수 있다.
  * 낮은 결합도란 책임과 관심사가 다른 오브젝트, 모듈과는 느슨하게 연결된 형태를 유지하는 것이다. 느슨한 연결을 위해서는 최소한의 방법만 간접적인 형태로 제공하고 나머지는 서로 독립적이고 알 필요도 없게 만들어주는 것이다. 즉 하나의 변경이 일어났을 때 여타 다른 모듈과 객체에 변경이 전파되지 않는 상태를 말한다.
* 전략 패턴 : 인터페이스를 이용하여 개선한 구조는 디자인 패턴으로 봤을때 `전략 패턴`에 해당한다. 전략패턴은 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부에 분리시키고, 이를 구현한 구체 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴이다.