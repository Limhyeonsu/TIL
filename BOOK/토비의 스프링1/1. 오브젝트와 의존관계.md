# 1. 오브젝트와 의존관계
스프링은 자바를 기반으로 한 기술로 가장 중요하게 가치를 두는 것이 바로 객체지향 프로그래밍이 가능하다는 것이다.

그래서 스프링을 이해하기 위해서는 `오브젝트`에 깊은 관심을 가져야 한다. 애플리케이션에서 오브젝트가 생성되고, 다른 오브젝트와 관계를 맺고 사용되고 소멸하기까지의 전 고정을 진지하게 생각해볼 필요가 있다.

오브젝트에 대한 관심은 기술적인 특징과 사용 방법을 넘어서 오브젝트 설계로 발전하게 된다. 

스프링은 오브젝트를 어떻게 효과적으로 설계하고 구현하고, 사용하고 이를 개선해나갈 것인가에 대한 명괘한 기준을 마련해준다.

## 1.1 초난감 DAO
54~59p

## 1.2 DAO의 분리
### 관심사의 분리
사용자의 비즈니스 프로세스와 그에 따른 요구사항은 끊임없이 바뀌고 발전한다. 애플리케이션이 기반을 두고 있는 기술도 시간이 지남에 따라 바뀌고, 운영되는 환경도 변화한다.

그래서 개발자가 객체를 설계할 떄 가장 염두에 둬야 할 사항은 바로 미래의 변화를 어떻게 대비할 것인가이다.

객체지향 설계와 프로그래밍이 이전의 절차적 프로그래밍 패러다임에 비해 초기에 좀 더 많은, 번거로운 작업을 요구하는 이유는 객체지향 기술 자체가 지니는 변화에 효과적으로 대처할 수 있다는 기술적인 특징 때문이다.

객체지향 기술은 실세계를 최대한 가깝게 모델링해낼 수 있고, 가상의 추상세계 자체를 효과적으로 구성할 수 있고, 이를 자유롭고 편리하게 변경, 발전, 확장시킬 수 있다는데 의미가 있다.

미래를 준비하는 데 있어 가장 중요한 과제는 변화에 어떻게 대비할 것인가이다. `가장 좋은 대책은 변화의 폭을 최소한으로 줄여주는 것이다.`

어떻게 변경이 일어날 때 필요한 작업을 최소화하고, 그 변경이 다른 곳에 문제를 일으키지 않게 할 수 있을까? 그것은 `분리와 확장을 고려한 설계가 있었기 때문이다.` 모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다. 문제는 변화는 대체로 한 가지 관심에서 일어나지만 그에 따른 작업은 한곳에 집중되지 않는 경우가 많다. 그러므로 우리가 준비할 일은 __한 가지 관심이 한 군데에 집중되게 하는 것이다. 즉 관심이 같은 것끼리 모으고, 관심이 다른것은 따로 떨어져 있게 하는 것이다.__

__관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고, 관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것이라 생각할 수 있다.__

### 커넥션 만들기의 추출
UserDao의 관심사항
```java
public class UserDao {

    public void add(User user) {
        //1. DB 커넥션 연결
        
        //2. SQL을 담을 Statement 만들고 실행
        
        //3. 작업이 끝난 Statement와 Connection 종료
    }
    
    public User get(String id) {
        //1. DB 커넥션 연결
        
        //2. SQL을 담을 Statement 만들고 실행
        
        //3. 작업이 끝난 Statement와 Connection 종료
    }
}
```
add(), get() 메서드에 중복된 코드가 발생한다. 이렇게 하나의 관심사가 방만하게 중복되어 있고, 여기저기 흩어져 있어서 다른 관심의 대상과 얽혀있으면 변경이 일어날 때 엄청난 고통을 일으키는 원인이 된다.

* 중복 코드의 메서드 추출 : 가장 먼저 커넥션을 가져오는 중복된 코드를 분리한다. getConnection()이라는 독립된 메서드로 만들고 각 DAO 메서드에서 getConnection() 메서드를 호출해서 DB 커넥션을 가져오게 만든다.
* 변경사항에 대한 검증(리팩토링과 테스트) : 변경된 UserDao의 기능이 변경하기 전과 동일한지 확인하기 위해 앞서 만든 테스트 코드를 실행하여 확인하면 된다.

위 작업은 기능에는 영향을 주지 않으면서 코드의 구조만 변경한다. 이러한 작업을 `리팩토링`이라고 한다. 그리고 getConnection() 메서드 처럼 공통의 기능을 담당하는 메서드로 중복된 코드를 뽑아내는 것을 리팩토링에서 `메서드 추출` 기법이라고 한다. 

### DB 커넥션 만들기의 독립
예) UserDao 클래스를 타 업체에 판매한다고 할 때 getConnection() 메서드는 업체마다 사용하는 DB가 달라 변경이 필요할 수 있다. 이때 유연하게 DB 별로 getConnection()을 사용하는 방법으로 기존 UserDao 코드를 한 단계 더 분리하여 추상메서드로 만든다.

추상클래스인 UserDao를 구입한 업체에서 추상메서드인 getConnection()을 상속받아 구현한다면 UserDao get(), add() 메서드에서 상용하는 getConnection() 메서드를 문제없이 사용할 수 있다.

이렇게 기본적인 로직의 흐름을 만들고 그 기능의 일부를 추상 메서드나 오버라이딩이 가능한 protected 메서드 등으로 만든 뒤 서브클래스에서 이런 메서드를 필요에 맞게 구현해서 사용하도록 하는 방법을 디자인 패턴에서 `템플릿 메서드 패턴`이라고 한다. (템플릿 메서드 패턴 - 변하지 않는 기능은 슈퍼클래스에 만들어두고, 자주 변경되며 확장할 기능은 서브클래스에서 만들도록 한다.)

UserDao의 getConnection() 메서드는 Connection 타입 오브젝트를 생성한다는 기능을 정의해놓은 추상 메서드이다. 그리고 UserDao의 서브클래스의 getConnection() 메서드는 어떤 Connection 클래스의 오브젝트를 어떻게 생성할 것인지를 결정하는 방법이라고도 볼 수 있다. __이렇게 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것을 `팩토리 메서드 패턴`이라고 한다.__ (팩토리 메서드 패턴 - 슈퍼 클래스에서 서브 클래스에서 구현한 메서드를 호출해서 필요한 타입의 오브젝트를 가져와 사용, 서브클래스에서 어떤 클래스의 오브젝트를 만들어 리턴할지 슈퍼클래스에서는 알지 못함)모두 같은 종류의 Connection 구현 클래스의 오브젝트를 리턴할 수도 있는데 오브젝트의 생성 방식이 다르다면, 이는 팩토리 메서드 패턴으로 이해할 수 있다.

템플릿 메서드 패턴, 팩토리 메서드 패턴을 사용하여 관심사를 분리하는 방법은 간단하면서 효과적이나 이 방법은 상속을 사용한다는 단점이 있다. 자바는 다중상속을 허용하지 않고, 상속을 통한 상하위 클래스의 관계는 많이 밀접하다. 따라서 상속관계는 다른 관심사에 대해 긴밀한 결합을 허용한다. 슈퍼클래스 내부의 변경이 생기면 모든 서브클래스를 함께 수정하거나 다시 개발해야 할 수도 있다.

## 1.3 DAO의 확장
### 클래스의 분리
위에서는 관심사를 분리할 때 1)독립된 메서드를 만들어서 분리, 2)상하위 클래스로 분리 했다. 

상속관계가 아닌 아예 독립된 클래스로 만드는 방법이 있다. 별도로 만든 클래스를 UserDao가 이용하게 한다.
```java
public class UserDao {
    private SimpleConnectionMaker simpleConnectionMaker;
    
    public UserDao() {
        simpleConnectionMaker = new SimpleConnectionMaker();
    }
    
    public void add(User user) {
        Connection c = simpleConnectionMaker.makeNewConnection();
        //...
    }
    
    public User get(String id) {
        Connection c = simpleConnectionMaker.makeNewConnection();
        //...
    }

}

```
이렇게 클래스를 분리하는 경우에도 상속을 이용했을때처럼 자유로운 확장이 가능하게 하려면 두가지 문제를 해결해야 한다. 1)여러 타 업체에서 다른 DB를 사용하는 경우 커넥션을 가져오는 코드를 일일히 변경해야한다. 2)DB 커넥션을 제공하는 클래스가 어떤것인지 UserDao가 구체적으로 알고 있어야 한다.

이런 문제의 원인은 UserDao가 DB 커넥션을 가져오는 구체적인 방법에 종속되기 때문이다. 
