# 1. 오브젝트와 의존관계
스프링은 자바를 기반으로 한 기술로 가장 중요하게 가치를 두는 것이 바로 객체지향 프로그래밍이 가능하다는 것이다.

그래서 스프링을 이해하기 위해서는 `오브젝트`에 깊은 관심을 가져야 한다. 애플리케이션에서 오브젝트가 생성되고, 다른 오브젝트와 관계를 맺고 사용되고 소멸하기까지의 전 고정을 진지하게 생각해볼 필요가 있다.

오브젝트에 대한 관심은 기술적인 특징과 사용 방법을 넘어서 오브젝트 설계로 발전하게 된다. 

스프링은 오브젝트를 어떻게 효과적으로 설계하고 구현하고, 사용하고 이를 개선해나갈 것인가에 대한 명괘한 기준을 마련해준다.

## 1.1 초난감 DAO
54~59p

## 1.2 DAO의 분리
### 관심사의 분리
사용자의 비즈니스 프로세스와 그에 따른 요구사항은 끊임없이 바뀌고 발전한다. 애플리케이션이 기반을 두고 있는 기술도 시간이 지남에 따라 바뀌고, 운영되는 환경도 변화한다.

그래서 개발자가 객체를 설계할 떄 가장 염두에 둬야 할 사항은 바로 미래의 변화를 어떻게 대비할 것인가이다.

객체지향 설계와 프로그래밍이 이전의 절차적 프로그래밍 패러다임에 비해 초기에 좀 더 많은, 번거로운 작업을 요구하는 이유는 객체지향 기술 자체가 지니는 변화에 효과적으로 대처할 수 있다는 기술적인 특징 때문이다.

객체지향 기술은 실세계를 최대한 가깝게 모델링해낼 수 있고, 가상의 추상세계 자체를 효과적으로 구성할 수 있고, 이를 자유롭고 편리하게 변경, 발전, 확장시킬 수 있다는데 의미가 있다.

미래를 준비하는 데 있어 가장 중요한 과제는 변화에 어떻게 대비할 것인가이다. `가장 좋은 대책은 변화의 폭을 최소한으로 줄여주는 것이다.`

어떻게 변경이 일어날 때 필요한 작업을 최소화하고, 그 변경이 다른 곳에 문제를 일으키지 않게 할 수 있을까? 그것은 `분리와 확장을 고려한 설계가 있었기 때문이다.` 모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다. 문제는 변화는 대체로 한 가지 관심에서 일어나지만 그에 따른 작업은 한곳에 집중되지 않는 경우가 많다. 그러므로 우리가 준비할 일은 __한 가지 관심이 한 군데에 집중되게 하는 것이다. 즉 관심이 같은 것끼리 모으고, 관심이 다른것은 따로 떨어져 있게 하는 것이다.__

__관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고, 관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것이라 생각할 수 있다.__

### 커넥션 만들기의 추출
UserDao의 관심사항
```java
public class UserDao {

    public void add(User user) {
        //1. DB 커넥션 연결
        
        //2. SQL을 담을 Statement 만들고 실행
        
        //3. 작업이 끝난 Statement와 Connection 종료
    }
    
    public User get(String id) {
        //1. DB 커넥션 연결
        
        //2. SQL을 담을 Statement 만들고 실행
        
        //3. 작업이 끝난 Statement와 Connection 종료
    }
}
```
add(), get() 메서드에 중복된 코드가 발생한다. 이렇게 하나의 관심사가 방만하게 중복되어 있고, 여기저기 흩어져 있어서 다른 관심의 대상과 얽혀있으면 변경이 일어날 때 엄청난 고통을 일으키는 원인이 된다.

* 중복 코드의 메서드 추출 : 가장 먼저 커넥션을 가져오는 중복된 코드를 분리한다. getConnection()이라는 독립된 메서드로 만들고 각 DAO 메서드에서 getConnection() 메서드를 호출해서 DB 커넥션을 가져오게 만든다.
* 변경사항에 대한 검증(리팩토링과 테스트) : 변경된 UserDao의 기능이 변경하기 전과 동일한지 확인하기 위해 앞서 만든 테스트 코드를 실행하여 확인하면 된다.

위 작업은 기능에는 영향을 주지 않으면서 코드의 구조만 변경한다. 이러한 작업을 `리팩토링`이라고 한다. 그리고 getConnection() 메서드 처럼 공통의 기능을 담당하는 메서드로 중복된 코드를 뽑아내는 것을 리팩토링에서 `메서드 추출` 기법이라고 한다. 

### DB 커넥션 만들기의 독립
예) UserDao 클래스를 타 업체에 판매한다고 할 때 getConnection() 메서드는 업체마다 사용하는 DB가 달라 변경이 필요할 수 있다. 이때 유연하게 DB 별로 getConnection()을 사용하는 방법으로 기존 UserDao 코드를 한 단계 더 분리하여 추상메서드로 만든다.

추상클래스인 UserDao를 구입한 업체에서 추상메서드인 getConnection()을 상속받아 구현한다면 UserDao get(), add() 메서드에서 상용하는 getConnection() 메서드를 문제없이 사용할 수 있다.

이렇게 기본적인 로직의 흐름을 만들고 그 기능의 일부를 추상 메서드나 오버라이딩이 가능한 protected 메서드 등으로 만든 뒤 서브클래스에서 이런 메서드를 필요에 맞게 구현해서 사용하도록 하는 방법을 디자인 패턴에서 `템플릿 메서드 패턴`이라고 한다. (템플릿 메서드 패턴 - 변하지 않는 기능은 슈퍼클래스에 만들어두고, 자주 변경되며 확장할 기능은 서브클래스에서 만들도록 한다.)

UserDao의 getConnection() 메서드는 Connection 타입 오브젝트를 생성한다는 기능을 정의해놓은 추상 메서드이다. 그리고 UserDao의 서브클래스의 getConnection() 메서드는 어떤 Connection 클래스의 오브젝트를 어떻게 생성할 것인지를 결정하는 방법이라고도 볼 수 있다. __이렇게 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것을 `팩토리 메서드 패턴`이라고 한다.__ (팩토리 메서드 패턴 - 슈퍼 클래스에서 서브 클래스에서 구현한 메서드를 호출해서 필요한 타입의 오브젝트를 가져와 사용, 서브클래스에서 어떤 클래스의 오브젝트를 만들어 리턴할지 슈퍼클래스에서는 알지 못함)모두 같은 종류의 Connection 구현 클래스의 오브젝트를 리턴할 수도 있는데 오브젝트의 생성 방식이 다르다면, 이는 팩토리 메서드 패턴으로 이해할 수 있다.

템플릿 메서드 패턴, 팩토리 메서드 패턴을 사용하여 관심사를 분리하는 방법은 간단하면서 효과적이나 이 방법은 상속을 사용한다는 단점이 있다. 자바는 다중상속을 허용하지 않고, 상속을 통한 상하위 클래스의 관계는 많이 밀접하다. 따라서 상속관계는 다른 관심사에 대해 긴밀한 결합을 허용한다. 슈퍼클래스 내부의 변경이 생기면 모든 서브클래스를 함께 수정하거나 다시 개발해야 할 수도 있다.

## 1.3 DAO의 확장
### 클래스의 분리
위에서는 관심사를 분리할 때 1)독립된 메서드를 만들어서 분리, 2)상하위 클래스로 분리 했다. 

상속관계가 아닌 아예 독립된 클래스로 만드는 방법이 있다. 별도로 만든 클래스를 UserDao가 이용하게 한다.
```java
public class UserDao {
    private SimpleConnectionMaker simpleConnectionMaker;
    
    public UserDao() {
        simpleConnectionMaker = new SimpleConnectionMaker();
    }
    
    public void add(User user) {
        Connection c = simpleConnectionMaker.makeNewConnection();
        //...
    }
    
    public User get(String id) {
        Connection c = simpleConnectionMaker.makeNewConnection();
        //...
    }

}

```
이렇게 클래스를 분리하는 경우에도 상속을 이용했을때처럼 자유로운 확장이 가능하게 하려면 두가지 문제를 해결해야 한다. 1)여러 타 업체에서 다른 DB를 사용하는 경우 커넥션을 가져오는 코드를 일일히 변경해야한다. 2)DB 커넥션을 제공하는 클래스가 어떤것인지 UserDao가 구체적으로 알고 있어야 한다.

이런 문제의 원인은 UserDao가 DB 커넥션을 가져오는 구체적인 방법에 종속되기 때문이다. 

### 인터페이스의 도입
UserDao가 DB 커넥션을 가져오는 구체적인 방법에 종속되는 문제는 중간에 추상적인 느슨한 연결고리를 만들어서 해결할 수 있다.(추상화: 어떤 것들의 공통적인 성격을 뽑아내어 이를 따로 분리해내는 작업)

자바에서 추상화를 위해 제공하는 유용한 도구는 바로 인터페이스다. 인터페이스로 추상화해놓은 최소한의 통로를 통해 접근하는 쪽에서 오브젝트를 만들때 사용할 클래스가 무엇인지 몰라도 된다. 인터페이스를 통해 접근하게 하면 실제 구현 클래스를 바꿔도 신경 쓸 일이 없다.

UserDao가 인터페이스를 사용한다면 인터페이스의 메서드를 통해 알 수 있는 기능에만 관심을 가지면 되지, 그 기능을 어떻게 구현했는지에는 관심을 둘 필요가 없다.

```java
public interface ConnectionMaker {
    public Connection makeConnection() throw ClassNotFoundException, SQLException;
}

public class UserDao {
    private ConnectionMaker connectionMaker;
    
    public UserDao() {
        //여전히 어떤 클래스의 오브젝트를 사용할지 정해야한다.
        connectionMaker = new AConnectionMaker();
    }
    
    public void add(User user) {
        Connection c = connectionMaker.makeConnection();
        //...
    }
    
    public User get(String id) {
        Connection c = connectionMaker.makeConnection();
        //...
    }

}

```

### 관계설정 책임의 분리
위 처럼 인터페이스를 사용하여도 여전히 어떤 클래스의 오브젝트를 사용할지 정해야한다는 문제가 있다. 그 이유는 UserDao안에 분리되지 않은 또 다른 관심사항이 존재하고 있기 때문이다.
UserDao 안에 어떤 ConnectionMaker 구현 클래스를 사용할지 결정하는 부분을 분리하지 않으면 UserDao는 결코 독립적으로 확장 가능한 클래스가 될 수 없다.

따라서 UserDao를 사용하는 클라이언트 오브젝트에서 UserDao를 사용하기 전에 ConnectionMaker 구현 클래스를 어떤 것을 사용할지 결정하도록 만들어보자. (오브젝트와 오브젝트 사이의 관계 설정)

외부에서 만든 오브젝트를 전달받기 위해 메서드 파라미터나 생성자 파라미터를 이용하면 된다. 이때 파라미터 타입이 인터페이스라면 해당 인터페이스를 구현한 클래스는 어떤 것이든 상관없이 전달 받을 수 있다.

UserDao 오브젝트가 동작하기 위해서는 특정 클래스의 오브젝트와 관계를 맺어야 한다. 하지만 클래스 사이에 관계가 만들어진 것은 아니고 단지 오브젝트 사이에 다이내믹한 관계가 만들어지는 것이다. 

코드에서 특정 클래스를 전혀 알지 못하더라도 해당 클래스가 구현한 인터페이스를 사용했다면 그 클래스의 오브젝트를 인터페이스 타입으로 받아서 사용할 수 있다.`(다형성)`

클라이언트는 자기가 UserDao를 사용해야하기 때문에 ConnectionMaker의 구현 클래스를 선택하고, 선택한 클래스의 오브젝트를 생성해서 UserDao와 연결해줄 수 있다. 기존 UserDao에서는 생성자에게 이 책임이 있었다.

```java
public class UserDao {
    private ConnectionMaker connectionMaker;
    
    public UserDao(ConnectionMaker connectionMaker) {
        this.connectionMaker = connectionMaker;
    }

    //...    

}

```

이렇게 하면 UserDao를 전혀 손대지 않고 모든 고객이 만족스럽게 DB 연결 기능을 확장해서 사용할 수 있게 된다.

인터페이스를 사용하는 방법은 상속을 사용한 방법에 비해 훨씬 유연하다. 

### 원칙과 패턴
* 개방 폐쇄 원칙 : 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다. 예)UserDao는 DB 연결 방법이라는 기능을 확장하는데는 열려있다. 동시에 핵심 기능을 구현한 코드는 그런 변화에 영향을 받지 않으므로 변경에는 닫혀있다. 인터페이스를 사용해 확장 기능을 정의한 대부분의 API는 이 개방 폐쇄 원칙을 따른다고 볼 수 있다.
* 높은 응집도와 낮은 결합도 : 
  * 높은 응집도란 하나의 모듈, 클래스가 하나의 책임(관심사)에만 집중되어 있다는 뜻이다. 따라서 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다는 것으로 설명할 수도 있다. 변경이 필요할 때 모듈의 많은 부분이 바뀐다면 응집도가 높다고 할 수 있다.
  * 낮은 결합도란 책임과 관심사가 다른 오브젝트, 모듈과는 느슨하게 연결된 형태를 유지하는 것이다. 느슨한 연결을 위해서는 최소한의 방법만 간접적인 형태로 제공하고 나머지는 서로 독립적이고 알 필요도 없게 만들어주는 것이다. 즉 하나의 변경이 일어났을 때 여타 다른 모듈과 객체에 변경이 전파되지 않는 상태를 말한다.
* 전략 패턴 : 인터페이스를 이용하여 개선한 구조는 디자인 패턴으로 봤을때 `전략 패턴`에 해당한다. 전략패턴은 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부에 분리시키고, 이를 구현한 구체 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴이다.

## 1.4 제어의 역전(IoC)
### 오브젝트 팩토리
위에서 했던 예제에서는 UserDao를 사용하는 클라이언트 측에서 ConnectionMaker의 구현 클래스를 결정하는 기능을 맡고있다. 하지만 UserDao를 사용하는 클라이언트 측에서  ConnectionMaker의 구현 클래스를 결정해야하는 책임을 떠맡게 되면서 관심사 분리가 되어 있지 않아 문제다. 따라서 이것또한 분리할 필요가 있다. 분리될 기능은 __UserDao와 ConnectionMaker 구현 클래스의 오브젝트를 만드는 것과 그렇게 만들어진 두 개의 오브젝트가 연결돼서 사용될 수 있도록 관계를 맺어주는 것이다.__

* 팩토리 : 객체의 생성방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 역할을 하는 클래스를 팩토리라 부른다. (디자인 패턴에서 사용하는 것과 다름) 단지 오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 역활과 책임을 깔끔하게 분리하려는 목적으로 사용된다.

```java
public class DaoFactory {
  //UserDao,  ConnectionMaker 관련 생성 작업을 DaoFactory에서 한다.
  public UserDao userDao() {
    ConnectionMaker connectionMaker = new AConnectionMaker();
    UserDao userDao = new UserDao(connectionMaker);
  }
}


//UserDao를 사용하는 클라이언트 쪽에서는 DaoFactory를 통해 AConnectionMaker를 사용한다.
UserDao userDao = new DaoFactory().userDao();
```

* 설계도로서의 팩토리 : DaoFactory는 애플리케이션을 구성하는 컴포넌트의 구조와 관계를 정의한 설계도 같은 역할을 한다고 볼 수 있다. DaoFactory를 분리했을 때 얻을 수 있는 장점은 매우 다양한다. 그중 애플리케이션의 컴포넌트 역할을 하는 오브젝트와 애플리케이션의 구조를 결정하는 오드젝트를 분리했다는 데 가장 의미가 있다.

### 오브젝트 팩도리의 활용
DaoFactory에서 UserDao가 아닌 다른 DAO의 생성 기능이 추가되는 경우 ConnectionMaker 구현 클래스의 오브젝트를 생성하는 코드가 메소드마다 반복되게 된다. DAO가 많아지면 ConnectionMaker의 구현 클래스를 바꿀 때마다 모든 메서드를 일일히 수정해야 한다. 

```java
public class DaoFactory {
  public UserDao userDao() {
    return new UserDao(connectionMaker());
  }
  public AccountDao accountDao() {
    return new AccountDao(connectionMaker());
  }
  public MessageDao messageDao() {
    return new MessageDao(connectionMaker());
  }
  
  //분리해서 중복을 제거한 connectionMaker 타입 오브젝트 생성
  public ConnectionMaker connectionMaker() { 
    return new ConnectionMaker();
  }
}
```

### 제어권의 이전을 통한 제어관계 역전
일반적으로 프로그램의 흐름은 main() 메서드와 같이 프로그램이 시작되는 지점에서 다음에 사용할 오브젝트를 결정하고, 결정한 오브젝트를 생성하고, 만들어진 오브젝트에 있는 메서드를 호출하고, 다음에 사용할 것을 결정하고 호출하는 식의 작업이 반복된다. 이때 흐름은 모든 종류의 작업을 사용하는 쪽에서 제어하는 구조로 되어있다.

제어의 역전은 이런 제어 흐름의 개념을 거꾸로 뒤집는 것이다. 제어의 역전에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다.(당연히 생성도 X) 또 자신도 어떻게 만들어지고 어디서 사용되는지를 알 수 없다. 

위 템플릿 메서드 패턴에서 슈퍼클래스인 UserDao의 add(), get() 메서드에서 connectionMaker가 필요할 때 호출해서 사용한다. 즉 제어권을 상위 템플릿 메서드에 넘기고 connectionMaker는 자신이 필요할때 호출되어 사용되도록 한다.

프레임워크도 제어의 역전 개념이 적용된 대표적인 기술이다. 프레임워크와 라이브러리의 차이점이 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어하고, 프레임워크는 애플리케이션 코드가 프레임워크에 의해 사용된다. 보통 프레임워크 위에 개발한 클래스를 등록해두고, 프레임워크가 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드를 사용하도록 만드는 방식이다. `프레임워크는 분명한 제어의 역전 개념이 적용되어 있어야 한다.`

위 예제에서 UserDao와 DaoFactory에도 제어의 역전이 적용되어 있다. 이제 ConnectionMaker의 구현 클래스를 결정하고 오브젝트를 만드는 제어권은 DaoFactory에 넘겨져서 UserDao는 수동적인 존재가 되었다. UserDao도 팩토리에 의해 수동적으로 만들어지고 자신이 사용할 오브젝트도 DaoFactory가 공급해주는 것을 수동적으로 사용할 입장이다. 이것이 제어의 역전이 일어난 상황이다.

## 1.5 스프링의 IoC
### 오브젝트 팩토리를 이용한 스프링 IoC
* 애플리케이션 컨텍스트와 설정정보 : 스프링에서는 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 `빈`이라고 부른다. 스프링에서는 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 빈 팩토리라고 부른다. 보통 빈 팩토리보다는 이를 좀더 확장한 `애플리케이션 컨텍스트`를 주로 사용한다. 애플리케이션 컨텍스트는 별도의 정보를 참고해서 빈의 생성, 관계설정 등의 제어 작업을 총괄한다. 애플리케이션 컨텍스트에서는 직접적인 설정정보를 담고 있지 않고, 별도로 설정정보를 담고 있는 무엇인가를 가져와 이를 활용하는 범용적인 IoC 엔진 같은 것이다.
* DaoFactory를 사용하는 애플리케이션 컨텍스트 : 스프링이 빈 팩도리를 위한 오브젝트 설정을 담당하는 클래스라고 인식할 수 있게 `@Configuration`이라는 애노테이션을 추가한다. 그리고 오브젝트를 만들어주는 메서드에 `@Bean`이라는 애노테이션을 붙여준다.

```java
@Configuration
public class DaoFactory {

  // 메서드 이름이 Bean의 이름이 된다.
  @Bean
  public UserDao userDao() {
    return new UserDao(connectionMaker());
  }
  
  @Bean
  public ConnectionMaker connectionMaker() { 
    return new ConnectionMaker();
  }
}

public class UserDaoTest {
  public static void main(String[] args) {
    ApplicationContext context = new AnnotationConfigApplicaionContext(DaoFactory.class);
    //getBean은 ApplicationContext가 관리하는 오브젝트를 요청하는 메서드다.
    UserDao dao = context.getBean("userDao", UserDao.class);
  
  }
}
```

### 애플리케이션 컨텍스트의 동작방식
클라이언트가 애플리케이션 컨텍스트의 getBean() 메서드를 호출하면 자신의 빈 목록에서 요청한 이름이 있는지 찾고, 있다면 빈을 생성하는 메서드를 호출해서 오브젝트를 생성시킨 후 클라이언트에 돌려준다. 애플리케이션 컨텍스트를 사용하는 이유는 범용적이고 유연한 방법으로 IoC 기능을 확장하기 위해서다. 

오브젝트 팩토리로 직접 사용했을 때와 비교해서 애플리케이션 컨텍스트를 사용했을 때 얻을 수 있는 장점은 다음과 같다.
1. 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.
2. 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다. - 오브젝트가 만들어지는 방식, 시점과 전략을 다르게 가져갈 수도 있고, 부가적으로 자동생성, 오브젝트에 대한 후처리, 정보의 조합, 설정 방식의 다변화, 인터셉팅 등 오브젝트를 효과적으로 활용할 수 있는 다양한 기능을 제공한다.
3. 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다.

### 스프링 IoC의 용어 정리
* 빈 : 스프링이 IoC 방식으로 관리하는 오브젝트라는 뜻이다. 스프링이 직접 생성과 제어를 담당하는 오브젝트만이 빈이다.
* 빈 팩토리 : 스프링의 IoC를 담당하는 핵심 컨테이너를 가리킨다. 빈을 등록, 수정, 조회, 반환 및 그 외에 부가적인 빈을 관리하는 기능을 담당한다.
* 애플리케이션 컨텍스트 : 빈 팩토리를 확장한 IoC 컨테이너다. 스프링이 제공하는 각종 부가 서비스를 추가로 제공한다.
* 설정정보/설정 메타정보
* 컨테이너 또는 IoC 컨테이너
* 스프링 프레임워크

## 1.6 싱글톤 레지스트리와 오브젝트 스코프
스프링 애플리케이션 컨텍스트는 기존에 직접 만들었던 오브젝트 팩토리와는 중요한 차이점이 있다. DaoFactory의 userDao() 를 여러번 호출했을 때 동일한 오브젝트가 돌아오는가? new 연산자에 의해 당연히 매번 다른 오브젝트가 반환될 것이라 생각할 수 있다.

스프링의 애플리케이션 컨텍스트에 DaoFactory를 설정정보로 등록한뒤 getBean()을 통해 오브젝트를 가져오게 되면 동일한 오브젝트를 반환한다. 즉 `스프링은 여러 번에 걸져 빈을 요청하더라도 매번 동일한 오브젝트를 돌려준다는 것이다.`

### 싱글톤 레지스트리로서의 애플리케이션 컨텍스트
애플리케이션 컨텍스트는 IoC 컨텍스트이다. 동시에 싱글톤을 저장하고 관리하는 `싱글톤 레지스트리`이기도 하다. 스프링에서는 기본적으로 별다른 설정을 하지 않으면 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만든다.

* 서버 애플리케이션과 싱글톤 : 태생적으로 스프링은 엔터프라이즈 시스템을 위해 고안된 기술이여서 대부분 서버환경에서 사용된다. 엔터프라이즈 환경에서 클라이언트에서의 요청시마다 오브젝트를 새로 생성하는 경우 부하가 걸려 서버가 감당하기 힘들어진다. 서블릿은 자바 엔터프라이즈 기술의 가장 기본이 되는 서비스 오브젝트인데 서블릿은 대부분 멀티스레드 환경에서 싱글톤으로 동작한다.
* 싱글톤 패턴의 한계 : 싱글톤 구현 방식은 생성자를 private으로 만들고, 생성된 싱글톤 오브젝트를 저장할 스태틱 필드를 정의한다. 그리고 스태틱 팩토리 메서드인 getInstance()를 만들어 이 메서드가 최초로 호출되는 시점에 한 번만 오브젝트가 만들어지게 한다. 마지막으로 한 번 오브젝트가 만들어지고 난뒤에는 이미 만들어진 스태틱 필드에 저장해둔 오브젝트를 반환한다. 이렇게 만들어진 싱글톤 패턴 방식에는 다음과 같은 문제가 있다.
  * private 생성자를 갖고 있기 때문에 상속 불가 - private 생성자를 가진 클래스는 다른 생성자가 없다면 상속이 불가능하다. (객체지향적 설계의 장점을 적용하기 어려움)
  * 싱글톤은 테스트하기 어려움
  * 서버 환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다 - 클래스 로더를 어떻게 구성하고 있느냐에 따라 싱글톤 클래스임에도 하나 이상의 오브젝트가 만들어질 수 있다.
  * 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.
* 싱글톤 레지스트리 : 자바의 기본적인 싱글톤 패턴의 구현방식은 여러가지 단점이 있기 때문에 __스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다.__ 그것이 바로 `싱글톤 레지스트리`이다. 싱글톤 레지스트리는 private 생성자나 스태틱 메서드를 사용해야 하는 비정상적인 클래스가 아니다. 따라서 public 생성자를 가질 수 있고, 테스트 환경에서도 자유롭게 오브젝트를 만들 수 있다.

### 싱글톤과 오브젝트의 상태
싱글톤은 멀티스레드 환경이라면 여러 스레드가 동시에 접근해서 사용할 수 있다. 따라서 상태 관리에 주의를 기울여야 한다. 기본적으로 싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우 상태 정보를 내부에 갖고 있지 않은 __무상태__ 방식으로 만들어져야 한다. 

스프링의 싱글톤 빈으로 사용되는 클래스를 만들때 개별적으로 바뀌는 정보는 로컬 변수로 정의하거나, 파라미터로 주고받으면서 사용하게 해야 한다.

### 스프링 빈의 스코프
스프링 빈의 기본 스코프는 싱글톤이다. 싱글톤 스코프는 컨테이너 내에 한 개의 오브젝트만 만들어져서 강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 계속 유지된다. 경우에 따라 빈은 싱글톤 외의 스코프를 가질 수 있다.(프로토타입 스코프, 요청 스코프, 세션 스코프)

## 1.7 의존관계 주입(DI)
### 제어의 역전(IoC)과 의존관계 주입
스프링 IoC 기능의 대표적인 동작원리는 주로 의존관계 주입이라고 불린다. 스프링이 여타 프레임워크와 차별화돼서 제공해주는 기능은 의존관계 주입이라는 새로운 용어를 사용할 때 분명하게 드러난다.
__(DI는 오브젝트 레퍼런스를 외부로부터 제공받고 이를 통해 여타 오브젝트와 다이내믹하게 의존관계가 만들어지는 것이 핵심이다.)__

### 런타임 의존관계 설정
* 의존관계 : 두 개의 클래스 또는 모듈이 의존관계에 있다고 말할 때는 항상 방향성을 부여해줘야 한다. 즉 누가 누구에게 의존하는 관계에 있다는 식이어야 한다. 의존한다는 말은 의존대상이 변하면 의존하는 쪽에 영향을 미친다는 뜻이다. (의존관계에는 방향성이 있다.)
* UserDao의 의존관계 : UserDao는 ConnectionMaker 인터페이스에 의존하고 있다. 하지만 ConnectionMaker의 구현 클래스의 내부에 변경이 생겨도 UserDao는 영향을 받지 않는다. 이렇게 인터페이스에 대해서만 의존관계를 만들어두면 인터페이스 구현 클래스와의 관계는 느슨해지면서 변화에 영향을 덜 받는 상태가 된다.(결합도가 낮음)
* UserDao의 의존관계 주입 : DaoFactory를 사용하여 런타임 시점에 UserDao가 사용할 ConnectionMaker 타입의 오브젝트를 결정하고 이를 생성한 후에 UserDao의 생성자 파라미터로 주입해서 UserDao가 ConnectionMaker의 오브젝트와 런타임 의존관계를 맺게 해준다.

의존관계 주입이란 다음의 세 가지 조건을 충족하는 작업이다.
1. 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해 인터페이스에만 의존하고 있어야 한다.
2. 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정한다. (제3의 존재란 관계설정 책임을 가진 코드를 분리해서 만들어진 오브젝트다)
3. 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공해줌으로써 만들어진다.

### 의존관계 검색과 주입
스프링이 제공하는 IoC 방법에는 의존관계 주입만 있는 것이 아니다. 의존관계를 맺는 방법이 외부로부터의 주입이 아니라 스스로 검색을 이용하기 때문에 의존관계 검색이라고 불리는 것도 있다. 의존관계 검색은 __자신이 필요로 하는 의존 오브젝트를 능동적으로 찾는다.__

스프링의 IoC 컨테이너인 애플리케이션 컨텍스트는 getBean() 이라는 메서드를 제공한다. 바로 이 메서드가 의존관계 검색에 사용되는 것이다. 

의존관계 검색과 의존관계 주입 방법중 의존관계 주입이 훨씬 다순하고 깔끔하다. 대개 의존관계 주입 방식을 사용하는 편이 낫다.

의존관계 검색 방식에서는 검색하는 오브젝트 자신은(예.UserDao) 스프링의 빈일 필요가 없다. 그냥 어디에선가 new 연산자를 통해 직접 만들어서 사용해도 된다. 반면 의존관계 주입에서는 UserDao와 ConnectionMaker 사이에 DI가 적용되려면 UserDao도 반드시 컨테이너가 만드는 빈 오브젝트여야 한다. `DI를 원하는 오브젝트는 먼저 자기 자신이 컨테이너가 관리하는 빈이 돼야 한다는 사실을 잊지 말자`

### 의존관계 주입의 응용
* 기능 구현의 교환 : 예)개발환경, 운영환경, 테스트환경에서 각각 다른 DB를 사용할 때 DI 방식을 사용하면 DaoFactory만 다르게 만들어두면 나머지 코드는 손대지 않고 각 환경에 맞게 오브젝트에 의존관계를 갖게 할 수 있다.
* 부가기능 추가

### 메서드를 이용한 의존관계 주입
메서드를 이용한 의존관계 주입은 다음과 같이 두 가지 방법이 있다.

* 수정자(setter) 메서드를 이용한 주입
* 일반 메서드를 이용한 주입

```java
public class UserDao {
  
 private ConnectionMaker connectionMaker;
 
 public void setConnectionMaker(ConnectionMaker connectionMaker) {
    this.connectionMaker = connectionMaker;
 }
}

@Configuration
public class DaoFactory {
  @Bean
  public UserDao userDao() {
    UserDao userDao = new UserDao();
    userDao.setConnectionMaker(connectionMaker());
    return userDao;
  }

}

```

## 1.8 XML을 이용한 설정
스프링은 DaoFactory와 같은 자바 클래스를 이용하는 것 외에도, 다양한 방법을 통해 DI 의존관계 설정정보를 만들 수 있다. 가장 대표적인 것이 XML이다.

|  | 자바 코드 설정정보             | XML 설정정보                 |
|---|------------------------|--------------------------|
|빈 설정파일| @Configuration         | <beans>                  |
|빈의 이름| @Bean methodName()     | <bean id="methodName"    |
|빈의 클래스| return new BeanClass() | class="a.b.c...BeanClass |

DaoFactory의 @Bean 메서드에 담긴 정보를 1:1로 XML의 태그와 애트리뷰트로 전환해주기만 하면 된다.

```xml
<beans>
  <bean id="connectionMaker" class="springbook.user.dao.AConnectionMaker">
  </bean>
  <bean id="userDao" class="springbook.user.dao.UserDao">
    <property name="aaconnectionMaker" ref="bbconnectionMaker" />
  </bean>
</beans>

```
property의 name은 DI에 사용할 수정자 메서드의 프로퍼티 이름이며, ref는 주입할 오브젝트를 정의한 빈의 ID다. ex) userDao.setAAConnectionMaker(bbconnectionMaker())
