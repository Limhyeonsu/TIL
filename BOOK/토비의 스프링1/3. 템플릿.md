# 3. 템플릿
## 3.1 다시보는 초단감 DAO
기존에 만들었던 UserDao에는 예외처리 기능이 빠져있었다. DB 커넥션을 통한 작업후에는 항상 자원을 반환해주는 작업을 해주어야 한다. DB 작업중 오류가 발생하는 경우 자원 반환 부분까지 실행되지 못하기 때문에 try~catch 블록을 이용하여 자원 반환을 한다.

## 3.2 변하는 것과 변하지 않는 것
### JDBC try/catch/finally 코드의 문제점
예외처리를 추가한 UserDao는 복잡한 try/catch/finally 블록이 이중으로 중첩해서 쓰이고 모든 메서드마다 반복된다. 이렇게 되면 메서드 마다 복사해서 넣거나 할때 누락될 수도 있고 나중엔 원인을 찾기 힘들어진다.

이러한 문제를 효과적으로 다룰 수 있는 방법이 있다. 바로 변하지 않는 하지만 많은 곳에서 중복되는 코드와 로직에 따라 자꾸 확장되고 자주 변하는 코드를 잘 분리해내는 작업이다.

### 분리와 재사용을 위한 디자인 패턴 적용
216~224p
* 메서드 추출
* 템플릿 메서드 패턴의 적용 : 템플릿 메서드 패턴은 상속을 통해 기능을 확장해서 사용하는 것이다. 변하지 않는 부분은 슈퍼클래스에 두고 변하는 부분은 추상 메서드로 정의해둬서 서브클래스에서 오버라이드하여 새롭게 정의해 쓰도록 하는 것이다. 단점으로는 DAO 로직마다 상속을 통해 새로운 클래스를 만들어야 한다는 점이다.
* 전략 패턴의 적용 : 오브젝트를 아예 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만드는 전략 패턴이다. 인터페이스를 만들어두고 실제 바뀌는 부분을 구현한 클래스를 만든다. 하지만 전략 패턴은 필요에 따라 컨텍스트는 그대로 유지되면서 전략을 바꿔 쓸 수 있다는 것인데 컨텍스트 안에서 이미 구체적인 전략 클래스를 사용하도록 고정되어 있다면 전략 패턴에도 OCP에도 들어맞지 않는다.
* DI 적용을 위한 클라이언트/컨텍스트 분리

```java
public interface StatementStrategy {
    PreparedStatement makePreparedStatement(Connection c) throws SQLException;
}

public class DeleteAllStatement implement StatementStrategy {
    public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
        //...
    }
}

//try~catch 문을 공통적으로 사용하기 위함
public void jdbcConextWithStatementStrategy(StatementStrategy stmt) throws SQLException {
    Connection c = null;
    PreparedStatement ps = null;
    
    try {
        c = dataSource.getConnection();
        ps = stmt.makePremaredStatement(c);
        
        ps.excuteUpdate();
    } catch (SQLException e) {
        throw e;
    } finally {
        //...
    }
}

//클라이언트 책임을 담당할 deleteAll() 메서드
public void deleteAll() {
    // 선정한 전략 클래스의 오브젝트 생성
    StatementStrategy st = new DeleteAllStatement();
    // 컨텍스트 호출, 전략 오브젝트 전달
    jdbcContextWithStatementStrategy(st);
}
```

## 3.3 JDBC 전략 패턴의 최적화
### 전략 클래스의 추가 정보
add() 메서드의 경우 delete와 달리 user라는 부가적인 정보가 필요하다. 

```java
public class AddStatement implement StatementStrategy {
    User user;
    
    public AddStatement(User user) {
        this.user = user;
    }
    
    public PreparedStatement makePreparedStatement(Connection c) {
        //...
        ps.setString(1, user.getId();
        ps.setString(2, user.getName();
        ps.setString(3, user.getPasswore();
    }
}

public void add(User user) {
    StatementStrategy st = new AddStatement(user);
    jdbcContextWithStatementStrategy(st);

}

```

### 전략과 클라이언트의 동거
위 구조에서 단점은 DAO 메서드마다 새로운 StatementStrategy 구현 클래스를 만들어야 한다는 점이다. 또 DAO 메서드에서 StatementStrategy에 전달할 User와 같은 부가적인 정보가 있는 경우 이를 위해 오브젝트를 전달받는 생성자와 이를 저장해둘 인스턴스 변수를 번거롭게 만들어야 한다는 점이다. 이 문제를 해결하는 방법으로 다음과 같은 방법이 있다.
* 로컬 클래스 : ex) UserDao 클래스 안에 add() 메서드 안에 내부클래스로 정의한다. 그렇게 되면 UserDao의 메서드 로직에 강하게 결합되게 된다. 
* 익명 내부 클래스

