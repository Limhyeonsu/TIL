# 2. 테스트
테스트의 작성은 스프링의 다양한 기술을 활용하는 방법을 이해하고 검증하고, 실전에 적용하는 방법을 익히는 데 효과적으로 사용될 수 있다.

## 2.1 UserDaoTest 다시보기
### 테스트의 유용성
테스트 코드를 만듬으로써 코드를 개선하는 과정에서 처음과 동일한 기능을 수행함을 보장받을 수 있었다.

테스트란 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서 만든 코드를 확신할 수 있게 해주는 작업이다. 또 테스트의 결과가 원하는 대로 나오지 않는 경우에는 코드나 설계에 결함이 있음을 알 수 있다. 이를 통해 코드의 결함을 제거해가는 작업(디버깅)을 거치게 되고, 최종적으로 테스트가 성공하면 모든 결함이 제거됐다는 확신을 얻을 수 있다.

### UserDaoTest의 특징
```java
public class UserDaoTest {
    public static void main(String[] args) throw SQLException {
        ApplicationContext context = new GenericXmlApplicationContext("applicaionContext.xml");
        
        UserDao dao = context.getBean("userDao", UserDao.class);
        
        User user = new User();
        user.setId("user");
        user.setName("유저");
        user.setPassword("userpwd");
        
        dao.add(user);
        
        System.out.println(user.getId() + "등록 성공");
        
        User user2 = dao.get(user.getId());
        System.out.println(user2.getName());
        System.out.println(user2.getPassword());\
        
        System.out.println(user2.getId() + "조회 성공");
    }
}

```

* 웹을 통한 DAO 테스트 방법의 문제점 : 웹 화면을 통해 값을 입력하여 기능을 수행하고, 결과를 확인하는 방법은 가장 흔히 쓰이는 방법이지만 DAO 테스트로서는 단점이 너무 많다. DAO뿐 아니라 서비스, 컨트롤러, JSP 뷰 등 모든 레이어의 기능을 다 만들고 나서야 테스트가 가능하다는 점이 큰 문제다.
* 작은 단위의 테스트 : 테스트하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트하는 것이 바람직하다. 관심사의 분리라는 원리가 테스트에도 적용된다. 테스트의 관심이 다르다면 테스트할 대상을 분리하고 집중해서 접근해야 한다.
* 자동수행 테스트 코드 : 매번 웹 화면을 띄우고 개발자가 스스로 값을 입력하고 또 조회를 위한 ID 값을 넣고 버튼을 누르는 등의 작업을 반복한다면 지루하고 불편할 것이다. 위 UserDaoTest에서 처럼 main() 메서드를 실행하는 간단한 방법만으로 테스트의 전 과정이 자동으로 진행된다. 이렇게 테스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요하다.
* 지속적인 개선과 점진적인 개발을 위한 테스트

### UserDaoTest의 문제점
* 수동 확인 작업의 번거로움 : 결국 등록된 값과 조회된 값이 일치하는지는 콘솔에 찍히기 때문에 사람이 직접 확인해야 한다.
* 실행 작업의 번거로움 : 아무리 간단히 실행 가능한 main() 메서드라고 하더라도 매번 그것을 실행하는 것은 번거롭다. 만약 DAO가 수백개가 되고 그에 대한 main() 메서드가 그만큼 만들어진다면 전체 기능을 테스트할때 수백개의 main() 메서드를 실행해야 한다.

## 2.2 UserDaoTest 개선
### 테스트 검증의 자동화
```java
if(!user.getName().equals(user2.getName())) {
    System.out.println("테스트 실패(name)");
}else if(!user.getPassword().equals(user2.getPassword())) {
    System.out.println("테스트 실패(password)");
}else {
    System.out.println("테스트 성공");
}
```
위 처럼 수정함으로써 테스트 수행과 테스트 값 적용, 그리고 결과 검증까지 모두 자동화했다.

### 테스트의 효율적인 수행과 결과 관리
이미 자바에는 실용적인 테스트를 위한 도구가 여러 가지 존재한다. 그중 JUnit은 유명한 테스트 지원 도구다.

* Junit 테스트로 전환 : JUnit은 프레임워크다. 따라서 IoC를 통해 개발자가 만든 클래스의 오브젝트를 생성하고 실행하는 일은 프레임워크에 의해 진행된다. 
* 테스트 메서드 전환 : main() 메서드가 아닌 일반 메서드로 테스트 코드를 옮긴다. 메서드 생성 조건은 1)public으로 선언, 2)@Test 애노테이션 붙이기
* 검증코드 전환 : if-else 문을 통해 검증하던 코드를 JUnit의 assertThat이라는 스태틱 메서드를 이용해 변경한다. ex) assertThat(user2.getName(), is(user.getName()));
* Junit 테스트 실행 : 어딘가에 있는 main() 메서드에서 JunitCore 클래스의 main() 메서드를 호출해준다. 메서드 파라미터에는 테스트 메서드를 가진 클래스의 이름을 넣어준다. JunitCore.main("springbook.user.dao.UserDaoTest");

JUnit은 assertThat()을 이용해 검증 했을 때 기대한 결과가 아니면 AssertionError를 던진다.

## 2.3 개발자를 위한 테스팅 프레임워크 JUnit
스프링의 핵심기능 중 하나인 스프링 테스트 모듈도 JUnit을 이용한다. 따라서 스프링의 기능을 익히기 위해서라도 JUnit은 꼭 사용할 줄 알아야 한다.

### JUnit 테스트 실행 방법
* IDE : 대부분의 IDE 툴에는 JUnit Test를 실행할 수 있는 버튼이 있고, 테스트 실행시 테스트 정보를 보여주는 뷰를 통해 테스트 진행 사항을 볼 수 있다.
* 빌드 툴 : 빌드 툴에서 제공하는 JUnit 플러그인이나 태스크를 이용해 JUnit 테스트를 실행할 수 있다. 실행 결과는 옵션에 따라 HTML이나 텍스트 파일의 형태로 보기 좋게 만들어진다. 예) 여러 개발자가 만든 코드를 모두 통합해서 테스트를 수행해야 할 때, 모든 코드를 가져와 통합하고 빌드한 뒤 테스트를 수행하는 것이 좋다. 그래서 빌드 스크립트를 이용해 JUnit 테스트를 실행하고 그 결과등을 메일 등으로 통보받는 방법을 사용하면 된다.

### 테스트 결과의 일관성
UserDaoTest 테스트를 실행전에 매번 DB의 USER 테이블 데이터를 모두 삭제해야 했다. 즉 문제는 별도의 준비 작업 없이는 성공해야 마땅할 테스트가 실패하기도 한다는 점이다. 반복적인 테스트를 했을 때 테스트가 실패하기도 하고, 성공하기도 한다면 이는 좋은 테스트라고 할 수가 없다. `코드에 변경사항이 없다면 테스트는 항상 동일한 결과를 내야 한다.`

### 포괄적인 테스트
테스트를 만들지 않는 것도 위험하지만 성의없이 테스트를 만들어서 문제가 있는 코드임에도 테스트가 성공하게 만드는 것은 더 위험하다. __특히 한 가지 결과만 검증하고 마는 것은 상당히 위험하다.__

JUnit은 특정한 테스트 메서드의 실행 순서를 보장해주지 않는다. 테스트의 기대 결과가 테스트 실행 순서에 영향을 받는다면 테스트를 잘못 만든 것이다. 모든 테스트는 항상 동일한 결과를 낼 수 있도록 해야 한다.

테스트 실행중 예외가 던져지는 경우 테스트 메서드의 실행은 중단되고 테스트는 실패한다. 이럴때 JUnit은 예외조건 테스트를 위한 방법을 제공해준다. `@Test(expected=EmptyResultDataAccessException.class)` 이런식으로 @Test에 expected를 붙이면 보통의 테스트와는 반대로 예외가 던져진 경우 테스트가 성공한다.

개발자가 테스트를 직접 만들 때 자주 하는 실수가 있다. 바로 성공하는 테스트만 골라서 만드는 것이다. `테스트를 작성할 때 부정적인 케이스를 먼저 만드는 습관을 들이는 것이 좋다.`

### 테스트가 이끄는 개발
테스트를 먼저 만들어서 테스트가 실패하는 것을 보고 나서 코드를 손대기 시작하는 경우도 있다. 좀 이상하다고 생각할 수 있지만 이런 개발 전략이 실제로 존재한다.

테스트에는 만들고 싶은 기능에대한 조건과 행위, 결과에 대한 내용이 잘 표현되어 있다. 잘 만들어진 테스트코드는 마치 잘 작성된 하나의 기능정의서처럼 보인다.

만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법이 있다. 이를 `테스트 주도 개발 (TDD)`라고 한다.

실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다는 것이 TDD의 기본 원칙이다. 이 원칙을 따랐다면 만들어진 모든 코드는 빠짐없이 테스트로 검증된 것이라고 볼 수 있다.

테스트는 코드를 작성한 후에 가능한 빨리 실행할 수 있어야 한다. 그러려면 테스트 없이 한 번에 너무 많은 코드를 만드는 것은 좋지 않다. 빨리 발견된 오류는 쉽게 대응할 수 있기 때문에 테스트 없이 오랜 시간 동안 코드를 만들고 나서 테스트를 하면 오류가 발생했을 때 원인을 찾기가 쉽지 않다.

### 테스트 코드 개선
필요하다면 테스트 코드도 언제든지 내부구조와 설계를 개선해서 좀 더 깔끔하고 이해하기 쉬우며 변경이 용이한 코드로 만들 필요가 있다.

JUnit 프레임워크는 테스트 메서드를 실행할 때 부가적으로 해주는 작업이 몇 가지 있다. 
* @Before : JUnit은 @Test가 붙은 메서드를 실행하기 전과 후에 각각 @Before, @After가 붙은 메서드를 자동으로 실행한다. 따라서 테스트 메서드들의 공통적 준비 작업과 정리 작업을 이 애너테이션이 붙은 메서드에 넣어두면 매우 편리하게 테스트할 수 있다.
* 픽스처 : 테스트를 수행하는데 필요한 정보나 오브젝트를 픽스처라고 부른다.

각 테스트 메서드를 실행할 때마다 테스트 클래스의 오브젝트를 새로 만든다. 한번 만들어진 오브젝트는 하나의 테스트 메서드를 사용하고 나면 버려진다. 매번 오브젝트를 새로 만드는 이유는 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장하기 위해서이다.

## 2.4 스프링 테스트 적용
애플리케이션 컨텍스트가 만들어질 때는 모든 싱글톤 빈 오브젝트를 초기화한다. 어떤 빈은 오브젝트가 생성될 때 자체적인 초기화 작업을 진행해서 많은 시간을 필요로 하고, 애플리케이션 컨텍스트가 초기화 될 때 어떤 빈은 독자적으로 많은 리소스를 할당하거나 독립적인 스레드를 띄우기도 한다. 그래서 테스트를 마칠때마다 빈이 할당한 리소스 등을 깔끔하게 정리해주지 않으면 다음 테스트에서 새로운 애플리케이션 컨텍스트가 만들어지면서 문제를 일으킬 수 있다.

### 테스트를 위한 애플리케이션 컨텍스트 관리
스프링은 JUnit을 이용하는 테스트 컨텍스트 프레임워크를 제공한다. 테스트 컨텍스트를 지원받으면 간단한 애너테이션 설정만으로 테스트에서 필요로 하는 애플리케이션 컨텍스트를 만들어서 모든 테스트가 공유하게 할 수 있다.

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="/applicationContext.xml")
public class UserDaoTest {
    @Autowired
    private ApplicationContext context;
    @Autowired
    private UserDao userDao;
    
    @Before
    public void setUp() {
        this.dao = this.context.getBean("userDao", UserDao.class);
    }
}

```
RunWith에서 SpringJUnit4ClassRunner라는 JUnit용 테스트 컨텍스트 프레임워크 확장 클래스를 지정해주면 테스트 진행 중 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리하는 작업을 진행한다.

* 테스트 메서드의 컨텍스트 공유 : JUnit 확장기능은 테스트가 실행되기 전에 딱 한번만 애플리케이션 컨텍스트를 만들어두고, 테스트 오브젝트가 만들어질 때마다 특별한 방법을 이용해 애플리케이션 컨텍스트 자신을 테스트 오브젝트의 특정 필드에 주입해준다. 스프링이 애플리케이션 컨텍스트 테스트 개수에 상관없이 한 번만 만들어서 공유하게 해줬기 때문에 테스트 수행 속도는 매우 빨라진다.
* 테스트 클래스의 컨텍스트 공유 : 여러개의 테스트 클래스가 있는데 모두 같은 설정파일을 가진 애플리케이션 컨텍스트를 사용한다면 스프링은 테스트 클래스 사이에서도 애플리케이션 컨텍스트를 공유하게 해준다.
* @Autowired : 스프링의 DI에 사용되는 애너테이션이다. 해당 애너테이션이 붙은 인스턴스 변수가 있다면 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내의 빈을 찾는다. 일치하는 빈을 찾으면 인스턴스 변수에 주입한다.(applicationContext.xml에 ApplicationContext라는 빈이 정의되어 있지 않아도 주입된 이유는 스프링 애플리케이션 컨텍스트는 초기화할 때 자기 자신도 빈으로 등록하기 때문이다.)

### DI와 테스트
UserDao와 DB 커넥션 생성 클래스 사이에 DataSource라는 인터페이스를 두고 있다. 그래서 UserDao는 자신이 사용하는 오브젝트의 클래스가 무엇인지 알 필요가 없다.

만약 우리는 절대로 DataSource의 구현 클래스를 바꾸지 않을 것이다. 라고 하는 경우 굳이 DataSource 인터페이스를 사용하고 DI를 통해 주입해주는 방식을 이용해야할까? 그래도 인터페이스를 두고 DI를 적용해야 한다.

1. 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없다. 언젠가 수정이 필요한 경우가 생겼을 때 시간과 비용의 부담을 줄여줄 수 있다.
2. 클래스의 구현 방식은 바뀌지 않는다 하더라도 인터페이스를 두고 DI를 적용해두면 다른 차원의 서비스 기능을 도입할 수 있다.
3. 효율적인 테스트를 솝쉽게 만들기 위해서라도 DI를 적용해야 한다. 테스트는 가능한 한 작은 단위로 해야하는데 DI가 작은 단위의 대상에 대해 독립적으로 만들어지고 실행되게 하는데 중요한 역할을 한다.

[테스트 코드에 의한 DI]

UserDao에는 DI 컨테이너가 의존관계 주입에 사용하도록 수정자 메서드를 만들어뒀다. 따라서 테스트 코드에서 DataSource 오브젝트를 변경할 수 있다. 

applicationContext.xml 에 정의된 DataSource 빈은 서버의 DB 풀 서비스와 연결해서 운영용 DB 커넥션을 돌려준다고 했을때 테스트시에 이 DataSource를 이용하게 되면 테스트를 실행하는 순간 deleteAll()에 의해 운영용 DB에 사용자 데이터가 모두 삭제될 수 있다. 

테스트용 DB에 연결해주는 DataSource를 테스트 내에서 직접 만들 수 있다. 

```java
//테스트 메서드에서 애플리케이션 컨텍스트의 구성, 상태를 변경한다는 것을 테스트 컨텍스트 프레임워크에 알려줌
@DirtiesContext
//..
public class UserDaoTest {
    //..
    
    @Before
    public void setUp() {
        //...
        
        DataSource dataSource = new SingleConnectionDataSource("jdbc:mysql"//localhost/testdb", "spring", "book", true);
        dao.setDataSource(dataSource);
    }
}
```

위 방법은 이미 애플리케이션 컨텍스트에서 applicationContext.xml 파일의 설정 정보를 따라 구성한 오브젝트를 가져와 의존관계를 강제로 변경한다. 그래서 @DirtiesContext 애노테이션을 사용하여 스프링의 테스트 프레임워크에게 해당 클래스의 테스트에서 애플리케이션 컨텍스트의 상태를 변경한다는 것을 알려준다.

테스트 컨텍스트는 이 애노테이션이 붙은 테스트 클래스에는 애플리케이션 컨텍스트 공유를 허용하지 않는다. 테스트 메서드를 수행하고 나면 매번 새로운 애플리케이션 컨텍스트를 만들어서 다음 테스트가 사용하게 해준다.

[테스트를 위한 별도의 DI 설정]

아예 테스트에서 사용될 DataSource 클래스가 빈으로 정의된 테스트 전용 설정파일을 따로 만들어두는 방법도 있다. test-applicationContext.xml 파일을 만들어서 dateSource 빈의 설정정보를 테스트용으로 바꾼다. 그리고 테스트 클래스에 @ContextConfiguration(locations="/test-applicationContext.xml") 로 설정한다.

[컨테이너 없는 DI 테스트]

마지막으로 아예 스프링 컨테이너를 사용하지 않고 테스트를 만드는 방법이 있다.

@RunWith를 사용하지도 않고, @Autowired를 사용하지도 않는다.
```java
public class UserDaoTest{
    UserDao dao;

    @Before
    public void setUp() {
        //...
        dao = new UserDao();
        
        DataSource dataSource = new SingleConnectionDataSource("jdbc:mysql"//localhost/testdb", "spring", "book", true);
        dao.setDataSource(dataSource);
    }
}

```

DataSource를 직접 만드는 번거로움은 있지만 애플리케이션 컨텍스트를 아예 사용하지 않으니 코드는 더 단순해지고 이해하기 편해졌다. 애플리케이션 컨텍스트가 만들어지는 번거로움이 없어져 그만큼 테스트 시간을 절약할 수 있다. 


`항상 스프링 컨테이너 없이 테스트할 수 있는 방법을 가장 우선적으로 고려하자` 그게 테스트 수행속도가 가장 빠르고 테스트 자체가 간결해진다. 복잡한 의존관계를 갖는 오브젝트를 테스트해야 하는 경우 스프링 설정을 이용한 DI 방식의 테스트를 이용하는 것이 편하다. 테스트용 설정 파일을 따로 만들어서 사용하자

## 2.5 학습 테스트로 배우는 스프링
다른 사람이 만든 코드와 기능에 대한 테스트를 작성하는 경우를 학습 테스트라고 한다.

학습 테스트의 목적은 자신이 사용할 API나 프레임워크의 기능을 테스트로 보면서 사용 방법을 익히려는 것이다. 따라서 기능에 대한 검증이 아닌 자신이 기술이나 기능에 얼마나 제대로 이해하고 있는지, 그 사용법을 바로 알고 있는지를 검증하려는게 목적이다.

학습 테스트는 테스트 대상보다는 테스트 코드 자체에 관심을 갖고 만들어야 한다.

### 학습 테스트의 장점
* 다양한 조건에 따른 기능을 손쉽게 확인해볼 수 있다
* 학습 테스트 코드를 개발 중에 참고할 수 있다 - 새로운 기술의 다양한 기능을 사용하는 코드를 만들어두면 실제 개발에서 샘플 코드로 참고할 수 있다.
* 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와준다 - 새로운 버전의 프레임워크나 제품을 학습 테스트에 먼저 적용하여 기존에 사용한 API나 기능에 변화가 있거나 새로운 버전에 버그가 있다면 미리 확인할 수 있다.
* 테스트 작성에 대한 좋은 훈련이 된다
* 새로운 기술을 공부하는 과정이 즐거워진다

학습 테스트는 당장 적용할 일부 기능의 사용법을 익히기 위해서만이 아니라 새로운 프레임워크나 기술을 전반적으로 공부하는 과정에서도 유용하다.

### 학습 테스트 예제
200~205p

### 버그 테스트
버그 테스트란 코드에 오류가 있을 때 그 오류를 가장 잘 드러내줄 수 있는 테스트를 말한다. 버그가 발생했을 때 무작정 코드를 수정하지 말고 먼저 버그 테스트를 만들고 일단 실패하게 만든뒤 버그 테스트가 성공할 수 있도록 애플리케이션 코드를 수정한다.

[버그 테스트의 장점]
1. 테스트의 완성도를 높여준다 - 기존 테스트에서 검증하지 못한 부분이 있기 때문에 오류가 발생했을 것이다. 이에 대해 테스트를 만들면 불충분한 테스트를 보완해준다.
2. 버그의 내용을 명확하게 분석하게 해준다 - 
3. 기술적인 문제를 해결하는 데 도움이 된다.