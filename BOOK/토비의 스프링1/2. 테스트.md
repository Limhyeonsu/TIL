# 2. 테스트
테스트의 작성은 스프링의 다양한 기술을 활용하는 방법을 이해하고 검증하고, 실전에 적용하는 방법을 익히는 데 효과적으로 사용될 수 있다.

## 2.1 UserDaoTest 다시보기
### 테스트의 유용성
테스트 코드를 만듬으로써 코드를 개선하는 과정에서 처음과 동일한 기능을 수행함을 보장받을 수 있었다.

테스트란 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서 만든 코드를 확신할 수 있게 해주는 작업이다. 또 테스트의 결과가 원하는 대로 나오지 않는 경우에는 코드나 설계에 결함이 있음을 알 수 있다. 이를 통해 코드의 결함을 제거해가는 작업(디버깅)을 거치게 되고, 최종적으로 테스트가 성공하면 모든 결함이 제거됐다는 확신을 얻을 수 있다.

### UserDaoTest의 특징
```java
public class UserDaoTest {
    public static void main(String[] args) throw SQLException {
        ApplicationContext context = new GenericXmlApplicationContext("applicaionContext.xml");
        
        UserDao dao = context.getBean("userDao", UserDao.class);
        
        User user = new User();
        user.setId("user");
        user.setName("유저");
        user.setPassword("userpwd");
        
        dao.add(user);
        
        System.out.println(user.getId() + "등록 성공");
        
        User user2 = dao.get(user.getId());
        System.out.println(user2.getName());
        System.out.println(user2.getPassword());\
        
        System.out.println(user2.getId() + "조회 성공");
    }
}

```

* 웹을 통한 DAO 테스트 방법의 문제점 : 웹 화면을 통해 값을 입력하여 기능을 수행하고, 결과를 확인하는 방법은 가장 흔히 쓰이는 방법이지만 DAO 테스트로서는 단점이 너무 많다. DAO뿐 아니라 서비스, 컨트롤러, JSP 뷰 등 모든 레이어의 기능을 다 만들고 나서야 테스트가 가능하다는 점이 큰 문제다.
* 작은 단위의 테스트 : 테스트하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트하는 것이 바람직하다. 관심사의 분리라는 원리가 테스트에도 적용된다. 테스트의 관심이 다르다면 테스트할 대상을 분리하고 집중해서 접근해야 한다.
* 자동수행 테스트 코드 : 매번 웹 화면을 띄우고 개발자가 스스로 값을 입력하고 또 조회를 위한 ID 값을 넣고 버튼을 누르는 등의 작업을 반복한다면 지루하고 불편할 것이다. 위 UserDaoTest에서 처럼 main() 메서드를 실행하는 간단한 방법만으로 테스트의 전 과정이 자동으로 진행된다. 이렇게 테스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요하다.
* 지속적인 개선과 점진적인 개발을 위한 테스트

### UserDaoTest의 문제점
* 수동 확인 작업의 번거로움 : 결국 등록된 값과 조회된 값이 일치하는지는 콘솔에 찍히기 때문에 사람이 직접 확인해야 한다.
* 실행 작업의 번거로움 : 아무리 간단히 실행 가능한 main() 메서드라고 하더라도 매번 그것을 실행하는 것은 번거롭다. 만약 DAO가 수백개가 되고 그에 대한 main() 메서드가 그만큼 만들어진다면 전체 기능을 테스트할때 수백개의 main() 메서드를 실행해야 한다.

## 2.2 UserDaoTest 개선
### 테스트 검증의 자동화
```java
if(!user.getName().equals(user2.getName())) {
    System.out.println("테스트 실패(name)");
}else if(!user.getPassword().equals(user2.getPassword())) {
    System.out.println("테스트 실패(password)");
}else {
    System.out.println("테스트 성공");
}
```
위 처럼 수정함으로써 테스트 수행과 테스트 값 적용, 그리고 결과 검증까지 모두 자동화했다.

### 테스트의 효율적인 수행과 결과 관리
이미 자바에는 실용적인 테스트를 위한 도구가 여러 가지 존재한다. 그중 JUnit은 유명한 테스트 지원 도구다.

* Junit 테스트로 전환 : JUnit은 프레임워크다. 따라서 IoC를 통해 개발자가 만든 클래스의 오브젝트를 생성하고 실행하는 일은 프레임워크에 의해 진행된다. 
* 테스트 메서드 전환 : main() 메서드가 아닌 일반 메서드로 테스트 코드를 옮긴다. 메서드 생성 조건은 1)public으로 선언, 2)@Test 애노테이션 붙이기
* 검증코드 전환 : if-else 문을 통해 검증하던 코드를 JUnit의 assertThat이라는 스태틱 메서드를 이용해 변경한다. ex) assertThat(user2.getName(), is(user.getName()));
* Junit 테스트 실행 : 어딘가에 있는 main() 메서드에서 JunitCore 클래스의 main() 메서드를 호출해준다. 메서드 파라미터에는 테스트 메서드를 가진 클래스의 이름을 넣어준다. JunitCore.main("springbook.user.dao.UserDaoTest");

JUnit은 assertThat()을 이용해 검증 했을 때 기대한 결과가 아니면 AssertionError를 던진다.

## 2.3 개발자를 위한 테스팅 프레임워크 JUnit
스프링의 핵심기능 중 하나인 스프링 테스트 모듈도 JUnit을 이용한다. 따라서 스프링의 기능을 익히기 위해서라도 JUnit은 꼭 사용할 줄 알아야 한다.

### JUnit 테스트 실행 방법
* IDE : 대부분의 IDE 툴에는 JUnit Test를 실행할 수 있는 버튼이 있고, 테스트 실행시 테스트 정보를 보여주는 뷰를 통해 테스트 진행 사항을 볼 수 있다.
* 빌드 툴 : 빌드 툴에서 제공하는 JUnit 플러그인이나 태스크를 이용해 JUnit 테스트를 실행할 수 있다. 실행 결과는 옵션에 따라 HTML이나 텍스트 파일의 형태로 보기 좋게 만들어진다. 예) 여러 개발자가 만든 코드를 모두 통합해서 테스트를 수행해야 할 때, 모든 코드를 가져와 통합하고 빌드한 뒤 테스트를 수행하는 것이 좋다. 그래서 빌드 스크립트를 이용해 JUnit 테스트를 실행하고 그 결과등을 메일 등으로 통보받는 방법을 사용하면 된다.

### 테스트 결과의 일관성
UserDaoTest 테스트를 실행전에 매번 DB의 USER 테이블 데이터를 모두 삭제해야 했다. 즉 문제는 별도의 준비 작업 없이는 성공해야 마땅할 테스트가 실패하기도 한다는 점이다. 반복적인 테스트를 했을 때 테스트가 실패하기도 하고, 성공하기도 한다면 이는 좋은 테스트라고 할 수가 없다. `코드에 변경사항이 없다면 테스트는 항상 동일한 결과를 내야 한다.`

### 포괄적인 테스트
테스트를 만들지 않는 것도 위험하지만 성의없이 테스트를 만들어서 문제가 있는 코드임에도 테스트가 성공하게 만드는 것은 더 위험하다. __특히 한 가지 결과만 검증하고 마는 것은 상당히 위험하다.__

JUnit은 특정한 테스트 메서드의 실행 순서를 보장해주지 않는다. 테스트의 기대 결과가 테스트 실행 순서에 영향을 받는다면 테스트를 잘못 만든 것이다. 모든 테스트는 항상 동일한 결과를 낼 수 있도록 해야 한다.

테스트 실행중 예외가 던져지는 경우 테스트 메서드의 실행은 중단되고 테스트는 실패한다. 이럴때 JUnit은 예외조건 테스트를 위한 방법을 제공해준다. `@Test(expected=EmptyResultDataAccessException.class)` 이런식으로 @Test에 expected를 붙이면 보통의 테스트와는 반대로 예외가 던져진 경우 테스트가 성공한다.

개발자가 테스트를 직접 만들 때 자주 하는 실수가 있다. 바로 성공하는 테스트만 골라서 만드는 것이다. `테스트를 작성할 때 부정적인 케이스를 먼저 만드는 습관을 들이는 것이 좋다.`

### 테스트가 이끄는 개발
테스트를 먼저 만들어서 테스트가 실패하는 것을 보고 나서 코드를 손대기 시작하는 경우도 있다. 좀 이상하다고 생각할 수 있지만 이런 개발 전략이 실제로 존재한다.

테스트에는 만들고 싶은 기능에대한 조건과 행위, 결과에 대한 내용이 잘 표현되어 있다. 잘 만들어진 테스트코드는 마치 잘 작성된 하나의 기능정의서처럼 보인다.

만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법이 있다. 이를 `테스트 주도 개발 (TDD)`라고 한다.

실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다는 것이 TDD의 기본 원칙이다. 이 원칙을 따랐다면 만들어진 모든 코드는 빠짐없이 테스트로 검증된 것이라고 볼 수 있다.

테스트는 코드를 작성한 후에 가능한 빨리 실행할 수 있어야 한다. 그러려면 테스트 없이 한 번에 너무 많은 코드를 만드는 것은 좋지 않다. 빨리 발견된 오류는 쉽게 대응할 수 있기 때문에 테스트 없이 오랜 시간 동안 코드를 만들고 나서 테스트를 하면 오류가 발생했을 때 원인을 찾기가 쉽지 않다.

### 테스트 코드 개선
필요하다면 테스트 코드도 언제든지 내부구조와 설계를 개선해서 좀 더 깔끔하고 이해하기 쉬우며 변경이 용이한 코드로 만들 필요가 있다.

JUnit 프레임워크는 테스트 메서드를 실행할 때 부가적으로 해주는 작업이 몇 가지 있다. 
* @Before : JUnit은 @Test가 붙은 메서드를 실행하기 전과 후에 각각 @Before, @After가 붙은 메서드를 자동으로 실행한다. 따라서 테스트 메서드들의 공통적 준비 작업과 정리 작업을 이 애너테이션이 붙은 메서드에 넣어두면 매우 편리하게 테스트할 수 있다.
* 픽스처 : 테스트를 수행하는데 필요한 정보나 오브젝트를 픽스처라고 부른다.

각 테스트 메서드를 실행할 때마다 테스트 클래스의 오브젝트를 새로 만든다. 한번 만들어진 오브젝트는 하나의 테스트 메서드를 사용하고 나면 버려진다. 매번 오브젝트를 새로 만드는 이유는 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장하기 위해서이다.

## 2.4 스프링 테스트 적용
애플리케이션 컨텍스트가 만들어질 때는 모든 싱글톤 빈 오브젝트를 초기화한다. 어떤 빈은 오브젝트가 생성될 때 자체적인 초기화 작업을 진행해서 많은 시간을 필요로 하고, 애플리케이션 컨텍스트가 초기화 될 때 어떤 빈은 독자적으로 많은 리소스를 할당하거나 독립적인 스레드를 띄우기도 한다. 그래서 테스트를 마칠때마다 빈이 할당한 리소스 등을 깔끔하게 정리해주지 않으면 다음 테스트에서 새로운 애플리케이션 컨텍스트가 만들어지면서 문제를 일으킬 수 있다.

### 테스트를 위한 애플리케이션 컨텍스트 관리
스프링은 JUnit을 이용하는 테스트 컨텍스트 프레임워크를 제공한다. 테스트 컨텍스트를 지원받으면 간단한 애너테이션 설정만으로 테스트에서 필요로 하는 애플리케이션 컨텍스트를 만들어서 모든 테스트가 공유하게 할 수 있다.

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="/applicationContext.xml")
public class UserDaoTest {
    @Autowired
    private ApplicationContext context;
    @Autowired
    private UserDao userDao;
    
    @Before
    public void setUp() {
        this.dao = this.context.getBean("userDao", UserDao.class);
    }
}

```
RunWith에서 SpringJUnit4ClassRunner라는 JUnit용 테스트 컨텍스트 프레임워크 확장 클래스를 지정해주면 테스트 진행 중 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리하는 작업을 진행한다.

* 테스트 메서드의 컨텍스트 공유 : JUnit 확장기능은 테스트가 실행되기 전에 딱 한번만 애플리케이션 컨텍스트를 만들어두고, 테스트 오브젝트가 만들어질 때마다 특별한 방법을 이용해 애플리케이션 컨텍스트 자신을 테스트 오브젝트의 특정 필드에 주입해준다. 스프링이 애플리케이션 컨텍스트 테스트 개수에 상관없이 한 번만 만들어서 공유하게 해줬기 때문에 테스트 수행 속도는 매우 빨라진다.
* 테스트 클래스의 컨텍스트 공유 : 여러개의 테스트 클래스가 있는데 모두 같은 설정파일을 가진 애플리케이션 컨텍스트를 사용한다면 스프링은 테스트 클래스 사이에서도 애플리케이션 컨텍스트를 공유하게 해준다.
* @Autowired : 스프링의 DI에 사용되는 애너테이션이다. 해당 애너테이션이 붙은 인스턴스 변수가 있다면 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내의 빈을 찾는다. 일치하는 빈을 찾으면 인스턴스 변수에 주입한다.(applicationContext.xml에 ApplicationContext라는 빈이 정의되어 있지 않아도 주입된 이유는 스프링 애플리케이션 컨텍스트는 초기화할 때 자기 자신도 빈으로 등록하기 때문이다.)


