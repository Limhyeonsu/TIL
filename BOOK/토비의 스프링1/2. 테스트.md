# 2. 테스트
테스트의 작성은 스프링의 다양한 기술을 활용하는 방법을 이해하고 검증하고, 실전에 적용하는 방법을 익히는 데 효과적으로 사용될 수 있다.

## 2.1 UserDaoTest 다시보기
### 테스트의 유용성
테스트 코드를 만듬으로써 코드를 개선하는 과정에서 처음과 동일한 기능을 수행함을 보장받을 수 있었다.

테스트란 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서 만든 코드를 확신할 수 있게 해주는 작업이다. 또 테스트의 결과가 원하는 대로 나오지 않는 경우에는 코드나 설계에 결함이 있음을 알 수 있다. 이를 통해 코드의 결함을 제거해가는 작업(디버깅)을 거치게 되고, 최종적으로 테스트가 성공하면 모든 결함이 제거됐다는 확신을 얻을 수 있다.

### UserDaoTest의 특징
```java
public class UserDaoTest {
    public static void main(String[] args) throw SQLException {
        ApplicationContext context = new GenericXmlApplicationContext("applicaionContext.xml");
        
        UserDao dao = context.getBean("userDao", UserDao.class);
        
        User user = new User();
        user.setId("user");
        user.setName("유저");
        user.setPassword("userpwd");
        
        dao.add(user);
        
        System.out.println(user.getId() + "등록 성공");
        
        User user2 = dao.get(user.getId());
        System.out.println(user2.getName());
        System.out.println(user2.getPassword());\
        
        System.out.println(user2.getId() + "조회 성공");
    }
}

```

* 웹을 통한 DAO 테스트 방법의 문제점 : 웹 화면을 통해 값을 입력하여 기능을 수행하고, 결과를 확인하는 방법은 가장 흔히 쓰이는 방법이지만 DAO 테스트로서는 단점이 너무 많다. DAO뿐 아니라 서비스, 컨트롤러, JSP 뷰 등 모든 레이어의 기능을 다 만들고 나서야 테스트가 가능하다는 점이 큰 문제다.
* 작은 단위의 테스트 : 테스트하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트하는 것이 바람직하다. 관심사의 분리라는 원리가 테스트에도 적용된다. 테스트의 관심이 다르다면 테스트할 대상을 분리하고 집중해서 접근해야 한다.
* 자동수행 테스트 코드 : 매번 웹 화면을 띄우고 개발자가 스스로 값을 입력하고 또 조회를 위한 ID 값을 넣고 버튼을 누르는 등의 작업을 반복한다면 지루하고 불편할 것이다. 위 UserDaoTest에서 처럼 main() 메서드를 실행하는 간단한 방법만으로 테스트의 전 과정이 자동으로 진행된다. 이렇게 테스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요하다.
* 지속적인 개선과 점진적인 개발을 위한 테스트

### UserDaoTest의 문제점
* 수동 확인 작업의 번거로움 : 결국 등록된 값과 조회된 값이 일치하는지는 콘솔에 찍히기 때문에 사람이 직접 확인해야 한다.
* 실행 작업의 번거로움 : 아무리 간단히 실행 가능한 main() 메서드라고 하더라도 매번 그것을 실행하는 것은 번거롭다. 만약 DAO가 수백개가 되고 그에 대한 main() 메서드가 그만큼 만들어진다면 전체 기능을 테스트할때 수백개의 main() 메서드를 실행해야 한다.

## 2.2 UserDaoTest 개선
### 테스트 검증의 자동화
```java
if(!user.getName().equals(user2.getName())) {
    System.out.println("테스트 실패(name)");
}else if(!user.getPassword().equals(user2.getPassword())) {
    System.out.println("테스트 실패(password)");
}else {
    System.out.println("테스트 성공");
}
```
위 처럼 수정함으로써 테스트 수행과 테스트 값 적용, 그리고 결과 검증까지 모두 자동화했다.

### 테스트의 효율적인 수행과 결과 관리
이미 자바에는 실용적인 테스트를 위한 도구가 여러 가지 존재한다. 그중 JUnit은 유명한 테스트 지원 도구다.

* Junit 테스트로 전환 : JUnit은 프레임워크다. 따라서 IoC를 통해 개발자가 만든 클래스의 오브젝트를 생성하고 실행하는 일은 프레임워크에 의해 진행된다. 
* 테스트 메서드 전환 : main() 메서드가 아닌 일반 메서드로 테스트 코드를 옮긴다. 메서드 생성 조건은 1)public으로 선언, 2)@Test 애노테이션 붙이기
* 검증코드 전환 : if-else 문을 통해 검증하던 코드를 JUnit의 assertThat이라는 스태틱 메서드를 이용해 변경한다. ex) assertThat(user2.getName(), is(user.getName()));
* Junit 테스트 실행 : 어딘가에 있는 main() 메서드에서 JunitCore 클래스의 main() 메서드를 호출해준다. 메서드 파라미터에는 테스트 메서드를 가진 클래스의 이름을 넣어준다. JunitCore.main("springbook.user.dao.UserDaoTest");

JUnit은 assertThat()을 이용해 검증 했을 때 기대한 결과가 아니면 AssertionError를 던진다.

## 2.3 개발자를 위한 테스팅 프레임워크 JUnit
스프링의 핵심기능 중 하나인 스프링 테스트 모듈도 JUnit을 이용한다. 따라서 스프링의 기능을 익히기 위해서라도 JUnit은 꼭 사용할 줄 알아야 한다.

### JUnit 테스트 실행 방법
* IDE : 대부분의 IDE 툴에는 JUnit Test를 실행할 수 있는 버튼이 있고, 테스트 실행시 테스트 정보를 보여주는 뷰를 통해 테스트 진행 사항을 볼 수 있다.
* 빌드 툴 : 빌드 툴에서 제공하는 JUnit 플러그인이나 태스크를 이용해 JUnit 테스트를 실행할 수 있다. 실행 결과는 옵션에 따라 HTML이나 텍스트 파일의 형태로 보기 좋게 만들어진다. 예) 여러 개발자가 만든 코드를 모두 통합해서 테스트를 수행해야 할 때, 모든 코드를 가져와 통합하고 빌드한 뒤 테스트를 수행하는 것이 좋다. 그래서 빌드 스크립트를 이용해 JUnit 테스트를 실행하고 그 결과등을 메일 등으로 통보받는 방법을 사용하면 된다.

### 테스트 결과의 일관성
UserDaoTest 테스트를 실행전에 매번 DB의 USER 테이블 데이터를 모두 삭제해야 했다. 즉 문제는 별도의 준비 작업 없이는 성공해야 마땅할 테스트가 실패하기도 한다는 점이다. 반복적인 테스트를 했을 때 테스트가 실패하기도 하고, 성공하기도 한다면 이는 좋은 테스트라고 할 수가 없다. `코드에 변경사항이 없다면 테스트는 항상 동일한 결과를 내야 한다.`

### 포괄적인 테스트
테스트를 만들지 않는 것도 위험하지만 성의없이 테스트를 만들어서 문제가 있는 코드임에도 테스트가 성공하게 만드는 것은 더 위험하다. __특히 한 가지 결과만 검증하고 마는 것은 상당히 위험하다.__

JUnit은 특정한 테스트 메서드의 실행 순서를 보장해주지 않는다. 테스트의 기대 결과가 테스트 실행 순서에 영향을 받는다면 테스트를 잘못 만든 것이다. 모든 테스트는 항상 동일한 결과를 낼 수 있도록 해야 한다.

테스트 실행중 예외가 던져지는 경우 테스트 메서드의 실행은 중단되고 테스트는 실패한다. 이럴때 JUnit은 예외조건 테스트를 위한 방법을 제공해준다. `@Test(expected=EmptyResultDataAccessException.class)` 이런식으로 @Test에 expected를 붙이면 보통의 테스트와는 반대로 예외가 던져진 경우 테스트가 성공한다.

개발자가 테스트를 직접 만들 때 자주 하는 실수가 있다. 바로 성공하는 테스트만 골라서 만드는 것이다. `테스트를 작성할 때 부정적인 케이스를 먼저 만드는 습관을 들이는 것이 좋다.`
