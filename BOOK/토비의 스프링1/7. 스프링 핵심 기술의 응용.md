# 7. 스프링 핵심 기술의 응용
## 7.1 SQL과 DAO의 분리
UserDao에서 SQL을 DAO에서 분리해보자 DB의 테이블, 필드 이름과 SQL 문장이 바뀔수도 있다. 어떤 이유든지 SQL 변경이 필요한 상황이 발생하면 SQL을 담고 있는 DAO 코드가 수정될 수밖에 없다.

### XML 설정을 이용한 분리

__개별 SQL 프로퍼티 방식__

```java
public class UserDaoJDBC implements UserDao {
    //...
    private String sqlAdd;
    
    public void setSqlAdd(String sqlAdd) {
        this.sqlAdd = sqlAdd;
    }
    
    //...


    public void add(User user) {
        this.jdbcTemplate.update(
            this.sqlAdd,
            user.getId(), user.getName(), user.getPassword(), user.getEmail(), user.getLevel().intValue(), user.getLogin(), user.getRecommend());
    }
}
```

```xml
<bean id="userDao" class="springbook.user.dao.UserDaoJdbc">
    <property name="dataSource" ref="dataSource"/>
    <property name="sqlAdd" value="insert into users(id, name, password, email, level, login, recommenc) values(?,?,?,?,?,?,?)"/>
</bean>
```

이제 add()에서 사용하는 SQL은 코드의 수정 없이 XML 설정을 바꾸는 것만으로도 자유롭게 수정이 가능하다. 하지만 이 방법은 매번 새로운 SQL이 필요할 때마다 프로퍼티를 추가하고 DI를 위한 변수와 수정자 메서드도 만들어줘야 한다.

__SQL 맵 프로퍼티 방식__

```java
public class UserDaoJDBC implements UserDao {
    //...
    private Map<String, String> sqlMap;
    
    public void setSqlMap(Map<String, String> sqlMap) {
        this.sqlMap = sqlMap;
    }
    
    //...


    public void add(User user) {
        this.jdbcTemplate.update(
            this.sqlMap.get("add"),
            user.getId(), user.getName(), user.getPassword(), user.getEmail(), user.getLevel().intValue(), user.getLogin(), user.getRecommend());
    }
}
```

```xml
<bean id="userDao" class="springbook.user.dao.UserDaoJdbc">
    <property name="dataSource" ref="dataSource"/>
    <property name="sqlMap">
        <map>
            <entry key="add" value="insert into users(id, name, password, email, level, login, recommenc) values(?,?,?,?,?,?,?)"/>
            <entry key="get" value="select * from users where id = ?"/>
            <entry key="getAll" value="select * from users order by id"/>
            <entry key="deleteAll" value="delete from users"/>
            <entry key="getCount" value="select count(*) from users"/>
            <entry key="update" value="update users set name = ?, password = ?, email = ?, level = ?, login = ?, recommend = ?  where id =?"/>
        </map>
    </property>
</bean>
```

이렇게 맵으로 만들면 새로운 SQL이 필요할 때 설정에 <entry>만 추가해주면 된다.

### SQL 제공 서비스
위 처럼 설정파일에 SQL을 두고 DI로 DAO가 사용하게 하면 손쉽게 SQL을 분리할 수 있지만 몇가지 문제점이 있다.
1. SQL과 DI 설정정보가 섞여 있어 복잡하고 관리하기에 안좋다.
2. 스프링의 설정파일로부터 생성된 오브젝트와 정보는 애플리케이션을 다시 시작하기 전에는 변경이 매우 어렵다.

__SQL 서비스 인터페이스__

SQL 서비스를 인터페이스로 정의한다.

```java
public interface SqlService {
    String getSql(String key) throws RuntimeException; //exception 부분 생략..
}

public class UserDaoJdbc implements UserDao {
    //...
    
    private SqlService sqlService;
    
    //setter

    //...
    
    
    public void add(User user) {
        this.jdbcTemplate.update(
            this.sqlService.getSql("userAdd"),
            user.getId(), user.getName(), user.getPassword(), user.getEmail(), user.getLevel().intValue(), user.getLogin(), user.getRecommend());
    }
}



```

__스프링 설정을 사용하는 단순 SQL 서비스__

SqlService 인터페이스에는 어떤 기술적인 조건이나 제약사항도 담겨있지 않다. 어떤 방법을 사용하든 상관없이 DAO가 요구하는 SQL을 돌려주기만 하면 된다. 

```java
public class SimpleSqlService implements SqlService {
    private Map<String, String> sqlMap;
    
    public void setSqlMap(Map<String, String> sqlMap) {
        this.sqlMap = sqlMap;
    }
    
    public String getSql(String key) throw RuntimeException {
        String sql = sqlMap.get(key);
        if(sql == null) throws new RuntimeException;
        else retruen sql;
    }
}

```

```xml
<bean id="userDao" class="springbook.user.dao.UserDaoJdbc">
    <property name="dataSource" ref="dataSource"/>
    <property name="sqlService" ref="sqlService"/>
    
</bean>

<bean id="sqlService" class="springbook.user.sqlService.SimpleSqlService">
    <property name="sqlMap">
        <map>
            <entry key="add" value="insert into users(id, name, password, email, level, login, recommenc) values(?,?,?,?,?,?,?)"/>
            <entry key="get" value="select * from users where id = ?"/>
            <entry key="getAll" value="select * from users order by id"/>
            <entry key="deleteAll" value="delete from users"/>
            <entry key="getCount" value="select count(*) from users"/>
            <entry key="update" value="update users set name = ?, password = ?, email = ?, level = ?, login = ?, recommend = ?  where id =?"/>
        </map>
    </property>
</bean>
```

이렇게 하면 UserDao를 포함한 모든 DAO는 SQL을 어디에 저장해두고 가져오는지에 대해서는 전혀 신경쓰지 않아도 된다. 구체적인 구현 방법과 기술에 상관없이 SqlService 인터페이스 타입의 빈을 DI 받아서 필요한 SQL을 가져다 쓰기만 하면 된다.