# 6. AOP
## 6.1 트랜잭션 코드의 분리
### 메서드 분리
트랜잭션이 적용된 코드를 보면 트랜잭션 경계 설정 코드와 비즈니스 로직 코드가 복잡하게 얽혀있는 듯 보이지만 뚜렷하게 두 가지 종류의 코드가 구분되어 있다.

```java
public void upgradeUserLevels() {
    //트랜잭션 경계설정
    TransactionStatus status = this.transactionManager.getTransaction(new DefaultTransactionDefinition());
    
    try {
        //비즈니스 로직
        //...
        
        //트랜잭션 경계설정
        this.transactionManager.commit(status);
    } catch (Exception e) {
        this.transactionManager.rollback(status);
          
    }

}

```
이 코드의 특징은 트랜잭션 경계설정의 코드와 비즈니스로직 토드간에 서로 주고 받는 정보가 없다는 점이다. 

이 성격이 다른 코드를 두 개의 메서드로 분리하는 할 수 있지 않을까?
```java
public void upgradeUserLevels() {
    //트랜잭션 경계설정
    TransactionStatus status = this.transactionManager.getTransaction(new DefaultTransactionDefinition());
    
    try {
        //비즈니스 로직
        upgradeLevelsInternal();
        
        //트랜잭션 경계설정
        this.transactionManager.commit(status);
    } catch (Exception e) {
        this.transactionManager.rollback(status);
          
    }

}

public void upgradeLevelsInternal() {
    //비즈니스 로직
}

```

### DI를 이용한 클래스의 분리
메서드를 분리해도 여전히 트랜잭션을 담당하는 기술적인 코드가 UserService에 자리잡고 있다. 아예 트랜잭션 코드가 존재하지 않는 것처럼 보이게 하기 위해서 간단한 방법으로는 트랜잭션 코드를 클래스 밖으로 뽑아내는 것이 있다.

UserService를 인터페이스로 만들고 기존 코드는 UserService 인터페이스의 구현 클래스를 만든다. 그러면 UserServiceTest에서 결합이 약해지고 직접 구현 클래스에 의존하지 않기 때문에 유연한 확장이 가능해진다.

이렇게 인터페이스를 이용해 구현 클래스를 클라이언트에 노출하지 않고 런타임 시 DI를 통해 적용하는 방법을 쓰는 이유는 일반적으로 구현 클래스를 바꿔가면서 사용하기 위해서다.

그런데 클라이언트에서 UserService의 기능을 제대로 이용하기 위해서는 트랜잭션이 적용돼야 한다. 그래서 UserService를 구현한 또 다른 구현 클래스를 만들어 트랜잭션 경계설정의 책임을 맡긴다. 그리고 비즈니스 로직을 담고 있는 UserService의 구현 클래스를 만들고 거기에는 실제적인 로직 처리 작업을 위임한다. 

* UserService 인터페이스 도입 - UserService 인터페이스를 만들고 UserServiceImpl이 구현하도록 한다. 이 클래스에서는 트랜잭션 관련 코드는 다 빼고 비즈니스 로직만 넣는다. 
* 분리된 트랜잭션 기능 - 비즈니스 트랜잭션 처리를 담은 UserServiceTx 클래스를 만들어서 UserService를 구현하게 만든다. 그리고 인터페이스를 구현한 다른 오브젝트에게 작업을 위임하게 한다. 그리고 트랜잭션 경계 설정이라는 부가적인 작업을 부여한다.

```java
public class UserServiceImpl implements UserService {
    UserService userService;
    PlatformTransactionManager transactionManager;
    
    public void setTransactionManager(PlatformTransactionManager transactionManager) {
        this.transactionManager = transactionManager;
    }
    
    public void setUserService(UserService userService) {
        this.userService = userService;
    }
    
    public void add(User user) {
        userService.add(user);
    }
    
    public void upgradeLevels(){
        TransactionStatus status = this.transactionManager.getTransaction(new DefaultTransactionDefinition());
        try {
            userService.upgradeUserLevels();
            this.transactionManager.commit(status);
        } catch(Exception e) {
            this.transactionManager.rollback(status);
        }
    }ㅕ
}

```

* 트랜잭션 적용을 위한 DI 설정 - 기존에 UserService 빈이 의존하고 있던 transactionManager는 UserServiceTx의 빈이, userDao와 mailSender는 UserServiceImpl 빈이 각각 의존하도록 프로퍼티 정보를 분리한다.
* 트랜잭션 분리에 따른 테스트 수정 - UserService가 인터페이스로 바뀌었기 때문에 빈을 가져다 쓰는 부분에 수정이 필요하다. @Autowired는 타입이 일치하는 빈을 찾아주는데 UserService 인터페이스 타입을 가진 두 개의 빈이 존재하기 때문에 빈을 하나로 결정할 수 없는 경우 필드 이름을 이용해서 빈을 찾는다.
* 트랜잭션 경계설정 코드 분리의 장점 - 이제 비즈니스로직을 담당하고 있는 UserServiceImpl의 코드를 작성할 때는 트랜잭션과 같은 기술적인 내용에는 전혀 신경쓰지 않아도 된다. 또 비즈니스 로직에 대한 테스트를 손쉽게 만들어 낼 수 있다는 장점이 있다.

## 6.2 고립된 단위 테스트
가장 편하고 좋은 테스트 방법은 가능한 한 작은 단위로 쪼개서 테스트하는 것이다. 이유는 테스트가 실패했을 때 그 원인을 찾기 쉽고, 테스트의 의도나 내용이 분명해지고 만들기도 쉬워지기 때문이다.

### 복잡한 의존관계 속의 테스트
UserService는 UserDao, MailSender, 트랜잭션 처리를 위한 PlatformTransactionManager와 의존관계를 갖고 있다. 따라서 테스트가 진행되는 동안에 의존관계를 갖는 오브젝트들이 같이 실행된다. 그로인해 UserService의 문제가 아닌 의존 오브젝트들에 문제로 인하여 테스트가 실패할 수도 있다. 

### 테스트 대상 오브젝트 고립시키기
그래서 테스트의 대상이 환경, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있다. 고립시키는 방법은 테스트를 위한 대역을 사용하는 것이다. 고립된 테스트 방식으로 만들면 아무리 그 기능이 수행돼도 그 결과가 DB 등을 통해서 남지 않아 검증하기 어려운 경우에는 해당 메서드가 수행되었는지 여부로 확인하는 작업이 필요하다.

417~421p

테스트를 위한 대역을 사용함으로써 테스트의 수행시간은 이전보다 분명히 빨라졌다. 테스트를 도와주는 목 오브젝트 외에는 사용자 관리 로직을 검증하는 데 직접적으로 피룡하지 않은 의존 오브젝트와 서비스를 제거한 덕분이다.

### 단위 테스트와 통합 테스트
단위 테스트는 사용자 관리 기능 전체를 하나의 단위로 볼 수 있고, 하나의 클래스나 하나의 메서드를 단위로 볼 수 있다. 책에서는 테스트 대상 클래스를 목 오브젝트등의 테스트 대역을 이용하여 외부 리소스를 사용하지 않도록 고립시키는 것을 단위 테스트라고 부르겠다.

반면 두 갱 이상의 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 외부 DB, 파일, 서비스 등 리소스가 참여하는 테스트는 통합 테스트라고 부른다.

테스트는 코드가 작성되고 빠르게 진행되는 편이 좋다. 코드를 만들고 오래 지난뒤 테스트를 작성하게 되면 테스트 대상 코드에 대한 이해가 떨어지기 때문에 불완전해지기 쉽고 작성하기도 번거롭다.

### 목 프레임워크
단위 테스트를 만들기 위해서는 `스텁이나 목 오브젝트의 사용이 필수적이다.` 하지만 목 오브젝트를 만드는 일은 가장 큰 짐이다. 그런데 이런 번거로운 목 오브젝트를 편리하게 작성하도록 도와주는 다양한 목 오브젝트 지원 프레임워크가 있다.

__Mockito 프레임워크__

목 프레임워크를 사용하면 목 클래스를 일일이 준비해둘 필요가 없다

```java
UserDao mockUserDao = mock(UserDao.class);
when(mockUserDao.getAll()).thenReturn(this.users);
verify(mockUserDao, times(2)).update(any(User.class));

```