# 6. AOP
## 6.1 트랜잭션 코드의 분리
### 메서드 분리
트랜잭션이 적용된 코드를 보면 트랜잭션 경계 설정 코드와 비즈니스 로직 코드가 복잡하게 얽혀있는 듯 보이지만 뚜렷하게 두 가지 종류의 코드가 구분되어 있다.

```java
public void upgradeUserLevels() {
    //트랜잭션 경계설정
    TransactionStatus status = this.transactionManager.getTransaction(new DefaultTransactionDefinition());
    
    try {
        //비즈니스 로직
        //...
        
        //트랜잭션 경계설정
        this.transactionManager.commit(status);
    } catch (Exception e) {
        this.transactionManager.rollback(status);
          
    }

}

```
이 코드의 특징은 트랜잭션 경계설정의 코드와 비즈니스로직 토드간에 서로 주고 받는 정보가 없다는 점이다. 

이 성격이 다른 코드를 두 개의 메서드로 분리하는 할 수 있지 않을까?
```java
public void upgradeUserLevels() {
    //트랜잭션 경계설정
    TransactionStatus status = this.transactionManager.getTransaction(new DefaultTransactionDefinition());
    
    try {
        //비즈니스 로직
        upgradeLevelsInternal();
        
        //트랜잭션 경계설정
        this.transactionManager.commit(status);
    } catch (Exception e) {
        this.transactionManager.rollback(status);
          
    }

}

public void upgradeLevelsInternal() {
    //비즈니스 로직
}

```

### DI를 이용한 클래스의 분리
메서드를 분리해도 여전히 트랜잭션을 담당하는 기술적인 코드가 UserService에 자리잡고 있다. 아예 트랜잭션 코드가 존재하지 않는 것처럼 보이게 하기 위해서 간단한 방법으로는 트랜잭션 코드를 클래스 밖으로 뽑아내는 것이 있다.

UserService를 인터페이스로 만들고 기존 코드는 UserService 인터페이스의 구현 클래스를 만든다. 그러면 UserServiceTest에서 결합이 약해지고 직접 구현 클래스에 의존하지 않기 때문에 유연한 확장이 가능해진다.

이렇게 인터페이스를 이용해 구현 클래스를 클라이언트에 노출하지 않고 런타임 시 DI를 통해 적용하는 방법을 쓰는 이유는 일반적으로 구현 클래스를 바꿔가면서 사용하기 위해서다.

그런데 클라이언트에서 UserService의 기능을 제대로 이용하기 위해서는 트랜잭션이 적용돼야 한다. 그래서 UserService를 구현한 또 다른 구현 클래스를 만들어 트랜잭션 경계설정의 책임을 맡긴다. 그리고 비즈니스 로직을 담고 있는 UserService의 구현 클래스를 만들고 거기에는 실제적인 로직 처리 작업을 위임한다. 