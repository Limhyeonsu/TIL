# 5. 서비스 추상화
## 5.1 사용자 레벨 관리 기능 추가
간단한 CRUD만 있었던 UserDao에 간단한 비즈니스 로직을 추가해본다. 

* 사용자 레벨은 BASIC, SILVER, GOLD 세 가지 중 하나
* 처음 가입시 BASIC 레벨, 이후 한 단계씩 업그레이드 된다.
* 가입 후 50회 이상 로그인시 BASIC에서 SILVER 레벨이 된다.
* SILVER 레벨이면서 30번 이상 추천을 받으면 GOLD 레벨이 된다.
* 사용자 레벨 변경 작업은 일정한 주기를 가지고 일괄적으로 진행된다. 변경 작업 전 조건을 충족하더라도 레벨의 변경이 일어나지 않는다.

### 필드 추가

```java
//1. Level enum 생성
public enum Level {
    BASIC(1), SILVER(2), GOLD(3);
    
    private final int value;
    
    Level(int velue) {
        this.value = value;
    }
    
    public int intValue() {
        return value;
    }
    
    public static Level valueOf(int value) {
        switch(value) {
            case 1: return BASIC;
            case 2: return SILVER;
            case 3: return GOLD;
            default: throw new AssertionError("Unknown value: " + value);
        }
    }
}

//2. User 필드 추가
public class User {
    //...
    Level level;
    int login;
    int recommend;
    
    // getter/setter ..
    
}

//3. 필드 추가에 따른 테스트 코드 수정

//4. UserDaoJdbc 수정
public class UserDaoJdbc implement UserDao {
    //...
    private RowMapper<User> userMapper = 
        new RowMapper<User>() {
            public User mapRow(ResultSet rs, int rowNum) throws SQLException {
                User user = new User();
                user.setId(rs.getString("id"));
                user.setName(rs.getString("name"));
                user.setPassword(rs.getString("password"));
                user.setLevel(Level.valueOf(rs.getInt("level")));
                user.setLogin(rs.getInt("login"));
                user.setRecommend(rs.getInt("recommend"));
                return user;
            }
        
        }
    
    public void add(User user) {
        this.jdbcTemplate.update("insert into users(id, name, password, level, login, recommend) values(?,?,?,?,?,?)", user.getId(), user.getName(), user.getPassword(), user.getLevel().intValue(), user.getLogin(), user.getRecommend());
    }
    
}
```
add 할 때 Level 타입의 level 필드는 DB에 저장할 수 있는 SQL 타입이 아니므로 정수형으로 값을 변환해주어야 한다. (user.getLevel().intValue()) 반대로 조회할 때는 ResultSet에서 DB 타입인 int로 level 정보를 가져와서 Level.valueOf()를 이용해 int 값을 Level 타입의 enum 오브젝트로 만들어서 setLevel() 매서드에 넣어줘야 한다.

### 사용자 수정 기능 추가
사용자 정보에 대한 수정이 발생했을때 SQL문에 WHERE 절을 빼먹는 경우 테스트로는 검증하지 못하는 오류가 발생할 수 있다. 따라서 수정하지 말아야할 로우의 내용이 그래도 남아있는지 확인도 필요하다.

수정 테스트의 경우 위 문제를 해결하기 위해
1. UPDATE, DELETE 처럼 테이블의 내용에 영향을 주는 SQL을 실행하면 영향받은 로우의 갯수를 반환해주는데 로우의 갯수를 검증한다.
2. 테스트 코드를 보강해서 원하는 사용자 외의 정보는 변경되지 않았음을 직접 확인한다.

### UserService.upgradeLevels()
사용자 관리 로직은 UserDaoJdbc에 두는것은 적당하지 않다. 비즈니스 로직을 다루기 위한 클래스를 새로 생성한다. (UserService)

UserService는 UserDao의 구현 클래스가 바뀌어도 영향받지 않도록 해야한다. 데이터 액세스 로직이 바뀌었다고 비즈니스 로직 코드를 수정하는 일이 있어서는 안 된다. 따라서 DAO의 인터페이스를 사용하고 DI를 적용해야 한다. DI를 적용하기 위해 UserService도 스프링 빈으로 등록한다.

```java
public class UserService {
    UserDao userDao;
    
    //setter

}
```

```xml
<bean id="userService" class="springbook.user.service.UserService">
    <property name="userDao" ref="userDao"/>
</bean>

<bean id="userDao" class="springbook.user.dao.UserDaoJdbc">
    <property name="dataSource" ref="dataSource"/>
</bean>
```

```java
public void upgradeLevels() {
    List<User> users = userDao.getAll();
    for(User user : users) {
        Boolean changed = null;
        if(user.getLevel() == Level.BASIC && user.getLogin() >= 50) {
            user.setLevel(Level.SILVER);
            changed = true;
        } else if(user.getLevel() == Level.SILVER && user.getRecommend() >= 30) {
            user.setLevel(Level.GOLD);
            changed = true;
        } else if(user.getLevel() == Level.GOLD) {
            changed = false;
        } else {
            changed = false;
        }
        
        if(changed) {
            userDao.update(user);
        }
    }
}

```

upgradeLevels() 테스트 - 적어도 가능한 모든 조건을 하나씩은 확인해봐야 한다. 
```java
@RunWith(...)
@ContextConfingration(...)
public class UserServiceTest {
    
    @Autowired
    UserService userService;
    List<User> users;
    
    @Before
    public void setUp() {
        users = Arrays.asList(
            new User("bumjin", "박범진", "p1", Level.BASIC, 49, 0),
            new User("joytouch", "강명성", "p2", Level.BASIC, 50, 0),
            new User("erwins", "신승한", "p3", Level.SILVER, 60, 29),
            new User("madnite1", "이상호", "p4", Level.SILVER, 60, 30),
            new User("green", "오민규", "p5", Level.GOLD, 100, 100)
        );
    }
    
    @Test
    public void upgradeLevels() {
        userDao.deleteAll();
        for(User user : users) userDao.add(user);
        
        userService.upgradeLevels();
        checkLevel(users.get(0), Level.BASIC);
        checkLevel(users.get(1), Level.SILVER);
        checkLevel(users.get(2), Level.SILVER);
        checkLevel(users.get(3), Level.GOLD);
        checkLevel(users.get(4), Level.GOLD);
    }
    
    private void checkLevel(User user, Level expectedLevel) {
        User userUpdate = userDao.get(user.getId());
        assertThat(userUpdate.getLevel(), is(expectedLevel));
    }
}

```

### UserService.add()
처음 가입하는 사용자는 기본적으로 BASIC 레벨이어야 한다.  add()를 호출할때 level 필드의 값이 null이라면 BASIC 레벨로 등록하도록 한다.

### 코드 개선
작성된 코드를 살펴볼 때는 다음과 같은 질문을 해볼 필요가 있다.
* 코드에 중복된 부분은 없는가?
* 코드가 무엇을 하는 것인지 이해하기 불편하지 않은가?
* 코드가 자신이 있어야 할 자리에 있는가?
* 앞으로 변경이 일어난다면 어떤것이 있을 수 있고, 그 변화에 쉽게 대응할 수 있게 작성되어 있는가?

__upgradeLevels() 메서드 코드의 문제점__

for 루프속에 들어있는 if/else-if/else 블록이 읽기 불편하다. 레벨의 변화 단계와 업그레이드 조건, 조건이 충족되었을때 해야할 작업이 한데 섞여있어 로직을 이해하기 쉽지 않다. 이런 if 조건 블록이 레벨 개수만큼 반복되다 보니 새로운 레벨이 추가되는 경우 Level enum노 수정해야하고, if 조건식과 블록을 추가해줘야 한다.

제대로 만들기 위해서는 조건을 두 단계에 걸쳐서 비교해야 한다. 첫 단계에서는 레벨을 확인하고 각 레벨별로 다시 조건을 판단하는 조건식을 넣어야 한다.

__upgradeLevels() 리팩토링__

```java
//1. 자주 변경될 가능성이 있는 구체적인 구현을 분리한다.
public void upgradeLevels() {
    List<User> users = userDao.getAll();
    for(User user: users) {
        if(canUpgradeLevel(user)) {
            upgradeLevel(user);
        }
    }
}

//2. user에 대해 업그레이드가 필요하면 true, 필요하지 않으면 false
private boolean canUpgradeLevel(User user) {
    Level currentLevel = user.getLevel();
    switch(currentLevel) {
        //레벨별로 구분해서 조건을 판단
        case BASIC: return (user.getLoing() >= 50);
        case SILVER: return (user.getRecommend() >= 30);
        case GOLD: return false;
        default: throw new IllegalArgumentException("Unknown Level : " + currentLevel);
    }
}

//3. 이렇게 하면 레벨이 늘어나는 경우 if문이 점점 길어지게 된다. (재수정 필요)
//UserService
private void upgradeLevel(User user) {
    if(user.getLevel() == Level.BASIC) user.setLevel(Level.SILVER);
    else if(user.getLevel() == Level.SILVER) user.setLevel(Level.GOLD);
    userDao.update(user);
}

//4. Level enum에서 다음 단계 레벨이 무엇인지 결정하도록 한다.
public enum Level {
    GOLD(3, null), SILVER(2, GOLD), BASIC(1, SILVER);
    
    private final int value;
    private final Level next;
    
    Level(int velue, Level next) {
        this.value = value;
        this.next = next;
        
    }
    
    public int intValue() {
        return value;
    }
    
    public Level nextLevel() {
        return this.next;
    }
    
    public static Level valueOf(int value) {
        switch(value) {
            case 1: return BASIC;
            case 2: return SILVER;
            case 3: return GOLD;
            default: throw new AssertionError("Unknown value: " + value);
        }
    }
}

//5. 사용자 정보가 변경되는 것을 UserService -> User로 옮긴다. User의 내부 정보가 변경되는 것은 User 스스로 다루는게 적절하다.
//User
public void upgradeLevel() {
    Level nextLevel = this.level.nextLevel();
    if(nextLevel == null) {
        throw new IllegalArgumentException(this.level + "은 업그레이드가 불가능합니다.");
    } else {
        this.level = nextLevel;
    }
}

//6. UserService 의 간결해진 upgradeLevel()
private void upgradeLevel(User user) {
    user.upgradeLevel();
    userDao.update(user);

```

위에서 개선한 코드를 살펴보면 각 오브젝트와 메서드가 각각 자기 몫의 책임을 맡아 일을 하는 구조로 만들어졌다. UserService, User, Level이 내부 정보를 다루는 자신의 책임에 충실한 기능을 갖고 있으면서 필요가 생기면 이런 작업을 수행해달라고 서로 요청하는 구조다. 각자 자기 책임에 충실한 작업만 하고 있어 코드를 이해하기도 쉽다.

`객체지향적인 코드는 다른 오브젝트의 데이터를 가져와서 작업하는 대신 데이터를 갖고 있는 다른 오브젝트에게 작업을 해달라고 요청한다. 오브젝트에게 데이터를 요구하지 말고 작업을 요청하라는 것이 객체지향 프로그래밍의 가장 기본이 되는 원리이기도 하다.`

```java
//User 테스트 추가
public class UserTest {
    //...
    
    @Test
    public void upgradeLevel() {
        Level[] levels = level.values();
        for(Level level: levels) {
            if(leve.nextLevel() == null) continue;
            user.setLevel(level);
            user.upgradeLevel();
            assertThat(user.getLevel(), is(leve.nextLevel());
        }
    }
    
    @Test(expected=IllegalArgumentException.class)
    public void cannotUpgradeLevel() {
        Level[] levels = level.values();
        for(Level level: levels) {
            if(leve.nextLevel() != null) continue;
            user.setLevel(level);
            user.upgradeLevel();
            assertThat(user.getLevel(), is(leve.nextLevel());
        }
    }
}


//UserService 테스트 수정
public class UserServiceTest {
    //...
    
    @Test
    public void upgradeLevels() {
        userDao.deleteAll();
        for(User user : users) userDao.add(user);
        
        userService.upgradeLevels();
        checkLevel(users.get(0), false);
        checkLevel(users.get(1), true);
        checkLevel(users.get(2), false);
        checkLevel(users.get(3), true);
        checkLevel(users.get(4), false);
    }
    
    private void checkLevel(User user, boolean upgraded) {
        User userUpdate = userDao.get(user.getId());
        if(upgraded) {
            assertThat(userUpdate.getLevel(), is(user.getLevel().nextLevel()));
        } else {
            assertThat(userUpdate.getLevel(), is(user.getLevel()));
        }
    }

}
```

UserService에서 레벨 변경의 기준이되는 최소 로그인 횟수와 추천인수를 상수로 변경한다.
```java
public static final int MIN_LOGCOUNT_FOR_SILVER = 50;
public static final int MIN_RECCOMEND_FOR_GOLD = 30;

//...

private boolean canUpgradeLevel(User user) {
    Level currentLevel = user.getLevel();
    switch(currentLevel) {
        case BASIC: return (user.getLoing() >= MIN_LOGCOUNT_FOR_SILVER);
        case SILVER: return (user.getRecommend() >= MIN_RECCOMEND_FOR_GOLD);
        case GOLD: return false;
        default: throw new IllegalArgumentException("Unknown Level : " + currentLevel);
    }
}
```

그리고 테스트에서도 UserService에 정의해둔 상수를 사용하도록 고친다.

숫자로만 되어 있는 경우 비즈니스 로직을 상세히 코멘트로 달아놓거나 설계문서를 참조하기 전에는 이해하기 힘들었던 부분이 이제는 무슨 의도로 어떤 값을 넣었는지 이해하기 쉬워졌다.