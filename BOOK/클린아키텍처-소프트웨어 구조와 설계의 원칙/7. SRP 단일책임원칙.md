# 7. SRP : 단일 책임 원칙
좋은 소프트웨어 시스템은 깔끔한 코드로부터 시작한다.

SOLID 원칙은 함수와 데이터 구조를 클래스로 배치하는 방법, 그리고 이들 클래스를 서로 결합하는 방법을 설명해준다. SOLID 원칙의 목적은 중간 수준의 소프트웨어 구조가 아래와 같도록 만든다.
* 변경에 유연하다.
* 이해하기 쉽다.
* 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.

SOLID 원칙 중에서 그 의미가 가장 잘 전달되지 못한 원칙은 바로 단일 책임 원칙(SRP)이다. 프로그래머가 이 원칙의 이름을 듣는다면 모든 모듈이 단 하나의 일만 해야한다는 의미로 받아들이기 쉽다.

단 하나의 일만 하라는 원칙은 따로 있다. 그 원칙은 SOLID 원칙이 아니며 SRP도 아니다.

SRP는 `단일 모듈은 변경의 이유가 오직 하나뿐이어야 한다.` 라고 역사적으로 기술되어 있다. 바꿔 말하면 `하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.`

원칙을 위반하는 징후들

### 1) 우발적 중복
예) 급여 애플리케이션의 클래스가 있는데 이 클래스의 세가지 메서드가 있다. 1)회계팀에서 기능을 정의하고, CFO 보고를 위해 사용하는 메서드, 2)인사팀에서 기능을 정의하고, COO 보고를 위해 사용하는 메서드, 3)데이터베이스 관리자가 기능을 정의하고, CTO 보고를 위해 사용하는 메서드

예에서 이 세 메서드를 단일 클래스에 배치하게되어 세 액터가 서로 결합되어 버렸다. 그리고 어느 한 곳에서 메서드에 수정 요청이 들어오게 되면 다른 액터들은 수정에 대한 사항을 알지 못하게 된다.

즉 SRP는 서로 다른 액터가 의존하는 코드를 서로 분리하라고 말한다.

### 2) 병합
메서드가 서로 다른 액터를 책임진다면 병합이 발생할 가능성이 확실히 높다. 두 명의 서로 다른 개발자가 서로 다른 팀에 속해있고, 서로 다른 요청을 받아 같은 클래스를 변경하게 되면 병합이 발생한다. 병합에는 위험이 뒤따른다.

이를 문제를 방지하기 위해서는 서로 다른 액터를 뒷받침하는 코드를 서로 분리하는 것이다.

### 해결책
가장 확실한 해결책은 데이터와 메서드를 분리하는 방식이다. 즉 아무런 메서드가 없는 간단한 데이터 구조 클래스를 만들어서 각각의 클래스가 공유하도록 한다. 각 클래스는 자신의 메서드에 반드시 필요한 소스 코드만을 포함하고, 세 클래스는 서로의 존재를 몰라야 한다.

### 결론
단일 책임 원칙은 메서드와 클래스 수준의 원칙이다. 하지만 이보다 상위의 두 수준에서도 다른 형태로 다시 등장한다. 컴포넌트 수준에서는 공통 폐쇄 원칙, 아키텍쳐 수준에서는 아키텍처 경계의 생성을 책임지는 변경의 축이 된다.