# 12. 컴포넌트
컴포넌트는 시스템의 구성요소로 배포할 수 있는 가장 작은 단위이다. 컴포넌트가 어떤 형태로 배포되든, 잘 설계된 컴포넌트라면 반드시 독립적으로 개발 가능한 능력을 갖춰야 한다.

## 컴포넌트의 간략한 역사
오늘날의 프로그래머는 프로그램을 메모리의 어느 위치에 로드할지 고민할 필요가 거의 없다. 하지만 프로그래밍 초창기에는 프로그램을 로드할 메모리의 위치를 정하는 일이 프로그래머가 가장 먼저 결정해야 하는 사항중 하나였다. 이 시절에는 프로그램의 위치가 한번 결정되면, 재배치가 불가능했다. 이 시절에는 라이브러리 함수에 접근할 떄도 라이브러리의 함수 소스 코드를 직접 애플리케이션 코드에 포함시켜서 단일 프로그램으로 컴파일했다. 이로인해 함수 라이브러리가 크면 클수록 컴파일은 더 오래 걸렸다.

컴파일 시간을 단축시키기 위해 프로그래머는 함수 라이브러리의 소스 코드를 애플리케이션 코드로부터 분리했다. 함수 라이브러리를 개별적으로 컴파일하고, 컴파일된 바이너리를 메모리의 특정 위치에 로드했다. 하지만 애플리케이션은 점점 커졌고, 결국 할당 공간을 넘어서게 되었다.

## 재배치성
해결책은 재배치가 가능한 `바이너리`였다. 지능적인 로더를 사용해서 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정하자는 것이었다.

로더는 재배치 코드가 자리할 위치 정보를 전달받고, 재배치 코드에는 로드한 데이터에서 어느 부분을 수정해야 정해진 주소에 로드할 수 있는지를 알려주는 플래그가 삽입되었다.

또 컴파일러는 재배치 가능한 바이너리 안의 함수 이름을 메타데이터 형태로 생성하도록 수정하였다. 프로그램이 라이브러리 함수를 호출한다면 컴파일러는 라이브러리 함수 이름을 외부 참조로 생성했다. 반면 라이브러리 함수를 정의하는 프로그램이라면 컴파일러는 해당 이름을 외부 정의로 생성했다. 이렇게 함으로써 외부 정의를 로드할 위치가 정해지기만 하면 로더가 외부 참조를 외부 정의에 링크시킬 수 있게 된다. >> `링킹 로더의 탄생`

## 링커
링커 로더의 등장으로 프로그래머는 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수 있게 되었다. 하지만...프로그램은 훨씬 더 커지게 되었고, 결국 링킹 로더가 너무 느려 참을 수 없는 지경에 다다랐다.

마침대 로드와 링크가 두 단계로 분리되었고, 프로그래머가 느린 부분에 해당하는 링크 과정을 맡아 링커라는 별도의 애플리케이션으로 이 작업을 처리하도록 만들었다. 링커는 링크가 완료된 재배치 코드를 만들어 주었고, 그 덕분에 로더의 로딩 과정이 아주 빨라졌다.

프로그램은 점점 더 커졌지만 디스크는 작아지기 시작했고, 놀랄만큼 빨라졌다. 컴퓨터 메모리는 저렴해져서 디스크에 저장된 많은 데이터를 모두 램에 캐싱할 수 있게 되었다. 이제 프로그램을 성장시키는 속도보다 링크 시간이 줄어드는 속도가 더 빨라졌다.