# 19. TCS 문

TCS는 트랜잭션 제어문이다.

## 19.1 트랜잭션
트랜잭션은 함께 수행해야 하는 작원의 논리적인 단위다. 예)계좌이체 트랜잭션은 출금 계좌의 잔고 차감 작업과 입금 계좌의 잔고를 증가시키는 작업으로 구성되고, 두 작업은 반드시 하나의 트랜잭션으로 수행되어야 한다.

### 19.1.1 구조
트랜잭션은 DML 문이나 SET TRANSACTION 문이 실행되면 시작되고, COMMIT 문이나 ROLLBACK 문이 실행되면 종료된다. 트랜잭션 시작시 내부에서는 undo segment가 할당되고, 트랜잭션 id가 부여된다. `V$TRANSACTION` 뷰에서 트랜잭션에 대한 정보를 조회할 수 있다.

COMMIT 문을 수행하면 트랜잭션이 종료되고, `V$TRANSACTION` 뷰를 다시 조회하면 결과가 반환되지 않는다.

### 19.1.2 SCN
SCN(System Change Number)은 오라클 데이터베이스의 논리적 TIMESTAMP로 데이터베이스 내부의 작업 순서를 식별하는 용도로 사용된다. 트랜잭션도 내부적으로 SCN을 사용한다.

```
SELECT cd, vl, ORA_ROWSCN, SCN_TO_TIMESTAMP (ORA_ROWSCN) AS c1
FROM t1;
```

ORA_ROWSCN 슈도 칼럼은 행의 SCN을 반환한다. 그리고 SCN_TO_TIMESTAMP는 SCN 값을 TIMESTAMP 값으로 변환할 수 있다.

## 19.2 기본 문법
### 19.2.1 COMMIT 문
COMMIT 문은 현재 트랜잭션의 변경 내용을 데이터베이스에 영구적으로 저장하고 트랜잭션을 종료한다.

### 19.2.2 ROLLBACK 문
ROLLBACK 문은 현재 트랜잭션의 변경 내용을 모두 취소하고 트랜잭션을 종료한다.

### 19.2.3 SAVEPOINT 문
SAVEPOINT 문은 롤백할 수 있는 저장점을 생성한다.

```
UPDATE t1 SET vl = vl - 10 WHERE ce = 2;

SAVEPOINT s1;

UPDATE t1 SET vl = vl + 10 WHERE cd = 1;

SAVEPOINT s2;

DELETE FROM t1;

SELECT * FROM t1;

ROLLBACK TO SAVEPOINT s2;
```

## 19.3 데이터 동시성
데이터 동시성은 다수의 사용자가 동일한 데이터에 동시에 접근할 수 있는 것을 말한다.

### 19.2.1 락킹 메커니즘
오라클 데이터베이스는 데이터 동시성을 보장하기 위해 락을 사용한다. 락은 자원의 사용을 직렬화하기 위한 방법 중 하나다.

오라클 데이터베이스는 다양한 락을 사용한다. TM 락은 테이블, TX 락은 트랜잭션에 설정되는 락이다. 

__LOCK TABLE 문__ : 수동으로 테이블에 TM 락을 설정할 수 있다. lockmode는 ROW SHARE, ROW EXCLUSIVE, SHARE, SHARE ROW EXCLUSIVE, EXCLUSIVE를 지정할 수 있다. 락을 설정할 수 없는 경우 NOWAIT은 즉시, WAIT integer는 지정한 integer 초 후 에러를 발생시킨다. 

```
LOCK TABLE t1 IN ROW EXCLUSIVE MODE;
```

### 19.3.2 동시성 제어
자동 락을 통한 동시성 보장이 불가능한 경우도 있다. multitier 환경에서는 개발자가 직접 데이터 동시성을 제어하는 편이 바람직하다.

1. 비관적 동시성 제어 : 다수의 사용자가 동일한 데이터를 동시에 갱신하는 일이 빈번하다고 가정하며, FOR UPDATE 절을 사용한다. (SELECT 문에 FOR UPDATE 절을 기술하면 조회한 행에 로우 레벨 락이 설정된다.)

```
SELECT * FROM t1 WHERE cd = 1 FOR UPDATE;
```

2. 낙관적 동시성 제어 : 다수의 사용자가 동일한 데이터를 동시에 갱신하는 일이 드물다고 가정한다. 
   a. 칼럼 확인 방식 - 변경할 값을 조회하여 저장하고, 값을 변경하기 전에 저장한 값의 변경 여부를 확인하는 방식이다. 변경할 값이 많은 경우 모든 값을 비교해야 하기 때문에 쿼리가 길어질 수 있다.
   b. 버전 확인 방식 - 버전 정보를 변수에 저장하고, 값을 변경하기 전에 저장한 버전 정보의 변경 여부를 확인하는 방식이다. 

## 19.4 데이터 일관성
데이터 일관성은 트랜잭션에 의한 변경을 일관된 상태로 볼 수 있는 것을 의미한다. 데이터 동시성과 데이터 일관성은 트레이드 오프 관계를 가진다. 동시성이 높아지면 일관성이 낮아지고, 일관성이 높아지면 동시성이 낮아진다.

### 19.4.1 문장 수준 읽기 일관성
단일 쿼리 수준의 읽기 일관성이다. 오라클은 다중 버전 읽기 일관성을 지원하기 때문에 락을 사용하지 않고 문장 수준 읽기 일관성을 보장한다.

### 19.4.2 트랜잭션 수준 읽기 일관성
트랜잭션 수준의 읽기 일관성은 `동일한 트랜잭션 내의 쿼리는 다시 조회하더라도 결과가 동일해야 한다.` 트랜잭션 수준 읽기 일관성을 보장하려면 트랜잭션 고립화 수준을 변경해야 한다.

[트랜잭션 고립화 수준]
* read uncommitted : 커밋되지 않은 데이터를 읽는 것을 허용
* read committed : 커밋된 데이터만 읽는 것을 허용
* repeatable reads : 트랜잭션 내에서 읽은 데이터는 갱신과 삭제를 금지
* serialiazble : 트랜잭션 내에서 읽은 테이블에 삽입을 금지, 설정시 SET TRANSACTION 문을 사용해야 한다.

읽기 일관성이 보장되지 않은 경우 dirty read(동일한 쿼리가 커밋되지 않은 데이터를 읽어 다른 결과를 반환), non-repeatable read(동일한 쿼리가 갱신 또는 삭제에 의해 다른 결과를 반환), phantom read(동일한 쿼리가 삽입에 의해 다른 결과를 반환) 의 이상현상이 발생할 수 있다.
