# 10. 해법
## 10.1 배열과 문자열 해법
### 10.1.1 중복이 없는가
문자열이 주어졌을 때, 이 문자열이 같은 문자가 중복되어 등장하는지 확인하는 알고리즘을 작성하라. 자료구초를 추가로 사용하지 않고 풀 수 있는 알고리즘 또한 고민하라

1. 먼저 면접관에게 아스키 문자열인지, 유니코드 문자열인지 물어봐야 한다. (컴퓨터 과학의 이해와 세부사항을 신경쓰고 있다는 인상을 주기 위해)
2. 문자 집합에서 i번째 문자가 배열 내에 존재하는지 표시하는 boolean 배열을 사용하자, 같은 원소에 2번 접근하면 false를 반환한다.
3. 문자열의 길이가 문자 집합의 크기보다 클 경우 바로 false 반환

#### 풀이
```java
//아스키 문자열이라고 가정한다
boolean isUniqueChars(String str) {
    if(str.length() > 128) return false;

    boolean[] char_set = new boolean[128];
    for(int i = 0; i < str.length(); i++>) {
        int val = str.charAt(i); //아스키 코드를 반환하기 때문에 int로 받나?
        //이 문자는 이미 문자열 내에 있음
        if(char_set[val]) {
            return false;
        }
        char_set[val] = true;
    }
    return true;
}
```

이 코드의 시간 복잡도는 O(n)이고, 공간 복잡도는 O(1)이다. 문자 집합의 크기를 미리 정해놓지 않는다면 공간 복잡도는 O(c), 시간 복잡도는 O(min(c, n))이 된다.

```java
//문자열이 소문자 a부터 z까지로 구성되는 경우 하나의int 변수만 사용해서 문제 풀기 가능
boolean isUniqueChars(String str) {
    int checker = 0;

    for(int i = 0; i < str.length(); i++>) {
        int val = str.charAt(i) - 'a';
        //이 문자는 이미 문자열 내에 있음
        if((checker & (1 << val)) > 0) {
            return false;
        }
        checker |= (1 << val);
    }
    return true;
}
```

자료구조를 추가로 사용할 수 없다면 다음과 같은 방법을 사용할 수 있다.
1. 문자열 내의 각 문자를 다른 모든 문자와 비교한다. 이렇게 하면 O(n²) 시간이 걸리고 공간 복잡도는 O(1)이 된다.
2. 입력 문자열을 수정해도 된다면, O(nlog n)시간에 문자열을 정렬한 뒤 문자열을 처음부터 훑어 나가면서 인접한 문자가 동일한지 검색해 볼 수도 있다.

### 10.1.2 순열 확인
**순열 관계라는 것은 두 문자열에서 사용된 문자는 같은데 문자의 순서만 다른 형태라는 것을 의미한다.

문자열 두 개가 주어졌을 때 이 둘이 서로 순열 관계에 있는지 확인하는 메서드를 작성하라.

1. 대소문자를 구별해서 따져야 하는지 확인이 필요
2. 공백은 어떻게 처리할지 확인 필요
3. 문자열의 길이가 다르다면 서로 순열 관계에 있을 수 없다.

#### 풀이
1)정렬하라 : 두 문자열이 순열 관계라면 이 둘은 같은 문자로 구성되어 있고, 순서만 다를 것이다. 따라서 문자열을 정렬하면 둘 다 같은 결과가 나와야 한다.

```java
public String sort(String s) {
    char[] content = s.toCharArray();
    Arrays.sort(content);
    return new String(content);
}

public boolean permutation(String s, String t) {
    if(s.length() != t.length()) {
        return false;
    }

    return sort(s).equals(sort(t));
}
```
위 알고리즘은 깔끔하면서 단순하고, 이해하기 쉽다. 효율성이 중요한 상황이라면 다른 식으로 구현해보자

2)문자열에 포함된 문자의 출현 횟수가 같은지 검사하라 : 두 문자열이 동일한 문자 개수를 갖고 있다는 점을 이용해서 알고리즘을 구현한다. 배열 두 개를 사용해서 각 문자열 내의 문자 출현 횟수를 기록한 다음, 두 배열을 비교한다.

```java
boolean permutation(String s, String t) {
    if(s.length() != t.length()) {
        return false;
    }
    // 실제 면접관에게 문자 집합 크기를 확인해야 한다. 이 예제에서는 아스키 사용함
    int[] letters = new int[128];

    char[] s_array = s.toCharArrays();
    for(char c : s_array) {
        letters[c]++;
    }

    for(int i = 0; i < t.length(); i++) {
        int c = (int) t.charAt(i);
        letters[c]--;
        if(letters[c] < 0) {
            return false;
        }
    }
    return true;
}
```

### 10.1.3 URLify
문자열에 들어 있는 모든 공백을 '%20'으로 바꾸는 메서드를 작성하라

문자열 조작 문제를 풀 때 널리 쓰이는 방법 중 하나는 `문자열을 뒤에서부터 거꾸로 편집해 나가는 것이다.`

```java
//문자열을 두 번 훑는다. 1번째는 공백 문자가 얼마나 있는지 확인 2번째는 역방향으로 진행하면서 문자열 편집
void replaceSpaces(char[] str, int trueLength) {
    int spaceCount = 0, index, i = 0;
    for(i = 0; i < trueLength; i++) {
        if(str[i] == ' ') {
            spaceCount++;
        }
    }

    index = trueLength + spaceCount * 2;
    if(trueLength < str.length) {
        str[trueLength] = '\0'; //배열의 끝
    }
    for(i = trueLength -1; i >= 0; i—) {
        if(str[i] == ' ') {
            str[index - 1] = '0';
            str[index - 2] = '2';
            str[index - 3] = '%';
            index = index - 3;
        } else {
            str[index - 1] = str[i];
            Index—;
        }
    }
}
```