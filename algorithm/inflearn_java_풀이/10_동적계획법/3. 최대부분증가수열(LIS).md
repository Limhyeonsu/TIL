# 3. 최대 부분 증가 수열
## 문제
```
N개의 자연수로 이루어진 수열이 주어졌을 때, 그 중에서 가장 길게 증가하는(작은 수에서 큰 수로) 원소들의 집합을 찾는 프로그램을 작성하라.
예를 들어, 원소가 2, 7, 5, 8, 6, 4, 7, 12, 3 이면 가장 길게 증가하도록 원소들을 차례대로 뽑아내면 2, 5, 6, 7, 12를 뽑아내어
길이가 5인 최대 부분 증가수열을 만들 수 있다.

첫째 줄은 입력되는 데이터의 수 N(3≤N≤1,000, 자연수)를 의미하고,
둘째 줄은 N개의 입력데이터들이 주어진다.

첫 번째 줄에 부분증가수열의 최대 길이를 출력한다.
```

입력 값 :
```
8
5 3 7 8 6 2 9 4
```

출력 값 :
```
4
```

## 풀이1) 
입력받은 배열의 순서는 유지되어야 한다. 배열의 수와 같은 다이내믹 배열 dy[n]으로 생성 ex) dy[3] 이면 arr[3]에 해당하는 숫자인 8을 마지막 항으로 생각하고 이 숫자보다 작은 수만 앞에 요소에서 올 수 있다.

arr {5 3 7 8 6 2 9 4}

1. dy[0] => arr[0] (5) 는 앞에 숫자가 없이 자기자신 하나가 끝이므로 1을 넣어준다.
2. dy[1] => arr[1] (3) 은 앞에 숫자 5 밖에 없는데 5는 3보다 크므로 카운트 하지 않는다. 그러므로 1
3. dy[2] => arr[2] (7) 은 3, 7이 될 수도 있고, 5, 7이 될수도 있다. 그러므로 2 ......
4. dy[6] => arr[6] (9) 보다 작은 값중 최대 값은 arr[3]에 해당하는 8이다. 그러므로 dy[3] +1 한 값을 넣는다.
5. 마지막엔 dy[i] 중에서 최대값을 반환한다.

dy {1 1 2 3 2 1 4 2}

```java
import java.util.*;
class Main{
	static int[] dy;
	public int solution(int[] arr){
		int answer=0;
		dy=new int[arr.length];
		dy[0]=1;
		for(int i=1; i<arr.length; i++){
			int max=0;
			for(int j=i-1; j>=0; j--){
				if(arr[j]<arr[i] && dy[j]>max) max=dy[j];
			}
			dy[i]=max+1;
			answer=Math.max(answer, dy[i]);
		}
		return answer;
	}

	public static void main(String[] args){
		Main T = new Main();
		Scanner kb = new Scanner(System.in);
		int n=kb.nextInt();
		int[] arr=new int[n];
		for(int i=0; i<n; i++){
			arr[i]=kb.nextInt();
		}
		System.out.print(T.solution(arr));
	}
}
```